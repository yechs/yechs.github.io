<!doctype html>
<html lang="zh-Hans" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.6">
<link rel="alternate" type="application/rss+xml" href="/zh-Hans/blog/rss.xml" title="Ye Shu Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/zh-Hans/blog/atom.xml" title="Ye Shu Blog Atom Feed">
<link rel="preconnect" href="https://www.google-analytics.com">
<link rel="preconnect" href="https://www.googletagmanager.com">
<script async src="https://www.googletagmanager.com/gtag/js?id=G-M3X8PGC98D"></script>
<script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-M3X8PGC98D",{})</script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.css" integrity="sha384-Um5gpz1odJg5Z4HAmzPtgZKdTBHZdw8S29IecapCSB31ligYPhHQZMIlWLYQGVoc" crossorigin="anonymous"><title data-react-helmet="true">内存泄漏 与 malloc chunk | Ye Shu</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://shuye.dev/zh-Hans/blog/malloc_chunk"><meta data-react-helmet="true" name="docusaurus_locale" content="zh-Hans"><meta data-react-helmet="true" name="docusaurus_tag" content="default"><meta data-react-helmet="true" property="og:title" content="内存泄漏 与 malloc chunk | Ye Shu"><meta data-react-helmet="true" name="description" content="我为什么写这篇文章"><meta data-react-helmet="true" property="og:description" content="我为什么写这篇文章"><meta data-react-helmet="true" property="og:image" content="https://shuye.dev/img/yechs.jpeg"><meta data-react-helmet="true" name="twitter:image" content="https://shuye.dev/img/yechs.jpeg"><meta data-react-helmet="true" property="og:type" content="article"><meta data-react-helmet="true" property="article:published_time" content="2021-08-13T00:00:00.000Z"><meta data-react-helmet="true" property="article:author" content="https://github.com/yechs"><meta data-react-helmet="true" property="article:tag" content="c++,pwn"><link data-react-helmet="true" rel="shortcut icon" href="/zh-Hans/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://shuye.dev/zh-Hans/blog/malloc_chunk"><link data-react-helmet="true" rel="alternate" href="https://shuye.dev/blog/malloc_chunk" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://shuye.dev/zh-Hans/blog/malloc_chunk" hreflang="zh-Hans"><link data-react-helmet="true" rel="alternate" href="https://shuye.dev/blog/malloc_chunk" hreflang="x-default"><link rel="stylesheet" href="/zh-Hans/assets/css/styles.2e558cc8.css">
<link rel="preload" href="/zh-Hans/assets/js/runtime~main.02f4c884.js" as="script">
<link rel="preload" href="/zh-Hans/assets/js/main.2b80505b.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_1oUP">跳到主要内容</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/zh-Hans/"><img src="/zh-Hans/img/yechs.jpeg" alt="Ye Shu" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/zh-Hans/img/yechs.jpeg" alt="Ye Shu" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><b class="navbar__title">@yechs</b></a><a class="navbar__item navbar__link" href="/zh-Hans/kb/intro">知识库</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/zh-Hans/blog">博客</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/yechs" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><a href="https://www.linkedin.com/in/yechs/" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>LinkedIn<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a href="#" class="navbar__link"><span><svg viewBox="0 0 20 20" width="20" height="20" aria-hidden="true" class="iconLanguage_3vod"><path fill="currentColor" d="M19.753 10.909c-.624-1.707-2.366-2.726-4.661-2.726-.09 0-.176.002-.262.006l-.016-2.063 3.525-.607c.115-.019.133-.119.109-.231-.023-.111-.167-.883-.188-.976-.027-.131-.102-.127-.207-.109-.104.018-3.25.461-3.25.461l-.013-2.078c-.001-.125-.069-.158-.194-.156l-1.025.016c-.105.002-.164.049-.162.148l.033 2.307s-3.061.527-3.144.543c-.084.014-.17.053-.151.143.019.09.19 1.094.208 1.172.018.08.072.129.188.107l2.924-.504.035 2.018c-1.077.281-1.801.824-2.256 1.303-.768.807-1.207 1.887-1.207 2.963 0 1.586.971 2.529 2.328 2.695 3.162.387 5.119-3.06 5.769-4.715 1.097 1.506.256 4.354-2.094 5.98-.043.029-.098.129-.033.207l.619.756c.08.096.206.059.256.023 2.51-1.73 3.661-4.515 2.869-6.683zm-7.386 3.188c-.966-.121-.944-.914-.944-1.453 0-.773.327-1.58.876-2.156a3.21 3.21 0 011.229-.799l.082 4.277a2.773 2.773 0 01-1.243.131zm2.427-.553l.046-4.109c.084-.004.166-.01.252-.01.773 0 1.494.145 1.885.361.391.217-1.023 2.713-2.183 3.758zm-8.95-7.668a.196.196 0 00-.196-.145h-1.95a.194.194 0 00-.194.144L.008 16.916c-.017.051-.011.076.062.076h1.733c.075 0 .099-.023.114-.072l1.008-3.318h3.496l1.008 3.318c.016.049.039.072.113.072h1.734c.072 0 .078-.025.062-.076-.014-.05-3.083-9.741-3.494-11.04zm-2.618 6.318l1.447-5.25 1.447 5.25H3.226z"></path></svg><span>简体中文</span></span></a><ul class="dropdown__menu"><li><a href="/blog/malloc_chunk" target="_self" rel="noopener noreferrer" class="dropdown__link" style="text-transform:capitalize">English</a></li><li><a href="/zh-Hans/blog/malloc_chunk" target="_self" rel="noopener noreferrer" class="dropdown__link dropdown__link--active" style="text-transform:capitalize">简体中文</a></li></ul></div><div class="react-toggle toggle_3Zt9 react-toggle--disabled"><div class="react-toggle-track" role="button" tabindex="-1"><div class="react-toggle-track-check"><span class="toggle_71bT">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">🌞</span></div><div class="react-toggle-thumb"></div></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper blog-wrapper blog-post-page"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_2ahu thin-scrollbar" aria-label="Blog recent posts navigation"><div class="sidebarItemTitle_2hhb margin-bottom--md">Recent Posts</div><ul class="sidebarItemList_2xAf"><li class="sidebarItem_2UVv"><a aria-current="page" class="sidebarItemLink_1RT6 sidebarItemLinkActive_12pM" href="/zh-Hans/blog/malloc_chunk">内存泄漏 与 malloc chunk</a></li><li class="sidebarItem_2UVv"><a class="sidebarItemLink_1RT6" href="/zh-Hans/blog/welcome">Me and My Broken Site(s)</a></li></ul></nav></aside><main class="col col--7" itemscope="" itemtype="http://schema.org/Blog"><article itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h1 class="blogPostTitle_GeHD" itemprop="headline">内存泄漏 与 malloc chunk</h1><div class="blogPostData_291c margin-vert--md"><time datetime="2021-08-13T00:00:00.000Z" itemprop="datePublished">2021年8月13日</time> · 10 分钟阅读</div><div class="row margin-top--md margin-bottom--sm"><div class="col col--6 authorCol_1R69"><div class="avatar margin-bottom--sm"><a href="https://github.com/yechs" target="_blank" rel="noopener noreferrer" class="avatar__photo-link avatar__photo"><img class="image_1yU8" src="https://avatars.githubusercontent.com/u/49149993" alt="Ye Shu"></a><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://github.com/yechs" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">Ye Shu</span></a></div><small class="avatar__subtitle" itemprop="description">Studying how C++ allocates and frees chunks in memory</small></div></div></div></div></header><meta itemprop="image" content="https://shuye.dev/img/yechs.jpeg"><div class="markdown" itemprop="articleBody"><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="how-it-all-started"></a>我为什么写这篇文章<a class="hash-link" href="#how-it-all-started" title="标题的直接链接">#</a></h2><p>在我暑期实习期间 debug 一个内存泄漏的问题时，我发现我使用的其中一个 API return 了一个裸指针，从而把这个目标的 ownership 转移给了调用者（我）。换言之，我现在需要负责在代码运行完毕之后手动 <code>delete</code> 掉这个指针。尽管这是一个 <a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#i11-never-transfer-ownership-by-a-raw-pointer-t-or-reference-t" target="_blank" rel="noopener noreferrer">非常糟糕的工程实践</a>，我开始对内存泄漏是如何产生的，以及 <code>delete[]</code> 是如何删除内存的产生了兴趣。</p><p>在做了一些研究与实验后，我写下了这篇文章。本文将试图回答三组问题：</p><ol><li>什么是内存泄漏？</li><li>对象是如何在 堆 (heap) 上被分配的？<code>delete[]</code> 如何知道它需要释放哪块内存？</li><li>我们如何预防内存泄漏？</li></ol><p>Stack Overflow 上的问题 <a href="https://stackoverflow.com/questions/197675/how-does-delete-know-the-size-of-the-operand-array" target="_blank" rel="noopener noreferrer">&quot;How does delete[] &#x27;know&#x27; the size of the operand array?&quot;</a> 其实已经大致回答了我们的第二个问题，但我还是决定更深入地探讨一下实际的内存空间是什么样的。</p><p>巧合的是，我和朋友 <a href="https://guozhen.dev" target="_blank" rel="noopener noreferrer">@gzhding</a> 刚好在最近的一次 CTF 比赛中合作了一道 堆利用 (heap exploitation) 的题目。因为这份经历，我学会了如何使用 <code>gdb</code> 调试并查看堆上的内存，以借其管中窥豹。</p><div class="admonition admonition-info alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>info</h5></div><div class="admonition-content"><p>注：我先写成了本文的英文版，之后才试图将其译回中文。因此如有可能的话，请<a href="https://shuye.dev/blog/malloc_chunk/" target="_blank" rel="noopener noreferrer">以英文阅读本文</a>，以避免一些因为翻译质量导致的语句不顺与理解困难。</p></div></div><div class="tocCollapsible_1PrD"><button type="button" class="clean-btn tocCollapsibleButton_2O1e">本页总览</button></div><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="what-are-memory-leaks"></a>什么是内存泄漏<a class="hash-link" href="#what-are-memory-leaks" title="标题的直接链接">#</a></h2><p>我们知道 <a href="https://www.cplusplus.com/doc/tutorial/dynamic/" target="_blank" rel="noopener noreferrer">C++ 能够在堆上动态地分配内存</a>。一个常见的例子是使用 <code>new[]</code> 创建数组，以及 <code>delete[]</code> 删除数组。</p><p>当我们在内存中创建了一个数组（即分配了一段内存用以存储这个对象）而又忘记删除它时，<a href="https://en.wikipedia.org/wiki/Memory_leak" target="_blank" rel="noopener noreferrer">内存泄漏</a> 就会发生。当指向这段内存的指针超出作用域 (scope) 时，正在运行的代码就丢失了对被分配的内存的知识。在最坏的情况下，如果内存泄漏在一个循环中发生，新分配的内存能够持续地堆积而不被释放，最终使得电脑变慢甚至崩溃。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="poc"></a>PoC<a class="hash-link" href="#poc" title="标题的直接链接">#</a></h3><p>以下有一段简单的 Proof of Concept (PoC) 代码。其中的 <code>main()</code> 函数调用了 <code>memory_leak()</code> 函数，后者又创建了一个由 26 个 <code>char</code> 组成的数组，并将大写英文字母填入它们。</p><div class="codeBlockContainer_K1bP"><div style="color:#bfc7d5;background-color:#292d3e" class="codeBlockTitle_eoMF">memory_leak.cpp</div><div class="codeBlockContent_hGly cpp"><pre tabindex="0" class="prism-code language-cpp codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token keyword" style="font-style:italic">void</span><span class="token plain"> </span><span class="token function" style="color:rgb(130, 170, 255)">memory_leak</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">{</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// Always delete pointers created by new to avoid memory leaks!</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token keyword" style="font-style:italic">char</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token plain">arr </span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">new</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">char</span><span class="token punctuation" style="color:rgb(199, 146, 234)">[</span><span class="token number" style="color:rgb(247, 140, 108)">26</span><span class="token punctuation" style="color:rgb(199, 146, 234)">]</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token keyword" style="font-style:italic">for</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token keyword" style="font-style:italic">int</span><span class="token plain"> i </span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token plain"> </span><span class="token number" style="color:rgb(247, 140, 108)">0</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"> i </span><span class="token operator" style="color:rgb(137, 221, 255)">&lt;</span><span class="token plain"> </span><span class="token number" style="color:rgb(247, 140, 108)">26</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"> i</span><span class="token operator" style="color:rgb(137, 221, 255)">++</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">{</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        arr</span><span class="token punctuation" style="color:rgb(199, 146, 234)">[</span><span class="token plain">i</span><span class="token punctuation" style="color:rgb(199, 146, 234)">]</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">char</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token number" style="color:rgb(247, 140, 108)">65</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">+</span><span class="token plain"> i</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"> </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// 65 is the ascii of &#x27;A&#x27;</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token punctuation" style="color:rgb(199, 146, 234)">}</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// The memory area is not freed!</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// delete[] arr;</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token punctuation" style="color:rgb(199, 146, 234)">}</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">int</span><span class="token plain"> </span><span class="token function" style="color:rgb(130, 170, 255)">main</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">{</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token function" style="color:rgb(130, 170, 255)">memory_leak</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token keyword" style="font-style:italic">return</span><span class="token plain"> </span><span class="token number" style="color:rgb(247, 140, 108)">0</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token punctuation" style="color:rgb(199, 146, 234)">}</span></span></code></pre><button type="button" aria-label="复制代码到剪贴板" class="copyButton_Ue-o clean-btn">复制</button></div></div><p>因为 <code>delete[]</code> 语句已经被注释掉，当函数 <code>memory_leak()</code> return 时，指针 <code>arr</code> 会超出作用域 (scope) 并导致这一内存区域被泄漏。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="a-deeper-look-into-the-memory"></a>初探内存<a class="hash-link" href="#a-deeper-look-into-the-memory" title="标题的直接链接">#</a></h3><div class="admonition admonition-note alert alert--secondary"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"></path></svg></span>note</h5></div><div class="admonition-content"><p>我使用了 <a href="https://github.com/hugsy/gef" target="_blank" rel="noopener noreferrer">GEF</a> (GDB Enhanced Features) 而不是原生 GDB 以获取经过美化的输出以及诸如 <code>heap</code> 一类的额外功能。</p></div></div><p>让我们以 <code>g++ -g3 memory_leak.cpp -o memory_leak</code> 来编译这个程序（<code>-g3</code> flag 会在编译时保存程序的调试信息）并使用 <code>gdb</code> 来验证这一内存泄漏。</p><p>我们将会在 <code>memory_leak()</code> 函数的最后打一个断点，并运行程序直到其触发断点。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly console"><pre tabindex="0" class="prism-code language-console codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">$ gdb memory_leak</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">gef➤  b 11</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">Breakpoint 1 at 0x1179: file memory_leak.cpp, line 11.</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">gef➤  r</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">[...]</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">─────────────────────────────────────────────────────────────── source:memory_leak.cpp+11 ────</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">      6          arr[i] = char(65 + i); // 65 is the ascii of &#x27;A&#x27;</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">      7      }</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">      8</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">      9      // The memory area is not freed!</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">     10      // delete[] arr;</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">●→   11  }</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">     12</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">     13  int main() {</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">     14      memory_leak();</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">     15      return 0;</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">     16  }</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">───────────────────────────────────────────────────────────────────────────────── threads ────</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">[#0] Id 1, Name: &quot;memory_leak&quot;, stopped 0x555555555179 in memory_leak (), reason: BREAKPOINT</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">─────────────────────────────────────────────────────────────────────────────────── trace ────</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">[#0] 0x555555555179 → memory_leak()</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">[#1] 0x555555555186 → main()</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">──────────────────────────────────────────────────────────────────────────────────────────────</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">gef➤  info locals</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">arr = 0x55555556aeb0 &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">gef➤  x/8xw 0x55555556aeb0</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">0x55555556aeb0: 0x44434241      0x48474645      0x4c4b4a49      0x504f4e4d</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">0x55555556aec0: 0x54535251      0x58575655      0x00005a59      0x00000000</span></span></code></pre><button type="button" aria-label="复制代码到剪贴板" class="copyButton_Ue-o clean-btn">复制</button></div></div><p>在程序触发断点后，我们打印出指针 <code>arr</code> 指向的地址及这块内存的内容。注意内存是以 <a href="https://zh.wikipedia.org/zh-cn/%E5%AD%97%E8%8A%82%E5%BA%8F#%E5%B0%8F%E7%AB%AF%E5%BA%8F" target="_blank" rel="noopener noreferrer">小端序</a> 存储的，因此 <code>0x44</code> (D) 排在 <code>0x43</code> (C)，<code>0x42</code> (B)，以及 <code>0x41</code> (A) 之前。</p><p>现在，让我们继续运行这个程序，直到函数 <code>memory_leak()</code> 运行完毕返回至 <code>main()</code>。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly gdb"><pre tabindex="0" class="prism-code language-gdb codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">gef➤  finish</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">[...]</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">─────────────────────────────────────────────────────────────── source:memory_leak.cpp+15 ────</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">     10      // delete[] arr;</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">●    11  }</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">     12</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">     13  int main() {</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">     14      memory_leak();</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain"> →   15      return 0;</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">     16  }</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">───────────────────────────────────────────────────────────────────────────────── threads ────</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">[#0] Id 1, Name: &quot;memory_leak&quot;, stopped 0x555555555186 in main (), reason: TEMPORARY BREAKPOINT</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">─────────────────────────────────────────────────────────────────────────────────── trace ────</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">[#0] 0x555555555186 → main()</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">──────────────────────────────────────────────────────────────────────────────────────────────</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">gef➤  info locals</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">No locals.</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">gef➤  x/8xw 0x55555556aeb0</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">0x55555556aeb0: 0x44434241      0x48474645      0x4c4b4a49      0x504f4e4d</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">0x55555556aec0: 0x54535251      0x58575655      0x00005a59      0x00000000</span></span></code></pre><button type="button" aria-label="复制代码到剪贴板" class="copyButton_Ue-o clean-btn">复制</button></div></div><p>既然 <code>memory_leak()</code> return 了，我们就丢失了指向内存地址 <code>0x55555556aeb0</code> 的指针 <code>arr</code>。但当我们打印出内存区域时，发现这些数据仍然存储在内存中，没有（也不会）被释放。这就是内存泄漏。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="verification-with-valgrind"></a>利用 Valgrind 进行验证<a class="hash-link" href="#verification-with-valgrind" title="标题的直接链接">#</a></h3><p>此外，我们能够使用如 <a href="https://valgrind.org" target="_blank" rel="noopener noreferrer">Valgrind</a> 一样的自动化工具来检查内存泄漏。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly console"><pre tabindex="0" class="prism-code language-console codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">$ valgrind --leak-check=full ./memory_leak</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">==382643== Memcheck, a memory error detector</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">==382643== Copyright (C) 2002-2017, and GNU GPL&#x27;d, by Julian Seward et al.</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">==382643== Using Valgrind-3.17.0 and LibVEX; rerun with -h for copyright info</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">==382643== Command: ./memory_leak</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">==382643==</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">==382643==</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">==382643== HEAP SUMMARY:</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">==382643==     in use at exit: 26 bytes in 1 blocks</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">==382643==   total heap usage: 2 allocs, 1 frees, 72,730 bytes allocated</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">==382643==</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">==382643== 26 bytes in 1 blocks are definitely lost in loss record 1 of 1</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">==382643==    at 0x484021F: operator new[](unsigned long) (vg_replace_malloc.c:579)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">==382643==    by 0x10914A: memory_leak() (memory_leak.cpp:3)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">==382643==    by 0x109185: main (memory_leak.cpp:14)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">==382643==</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">==382643== LEAK SUMMARY:</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">==382643==    definitely lost: 26 bytes in 1 blocks</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">==382643==    indirectly lost: 0 bytes in 0 blocks</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">==382643==      possibly lost: 0 bytes in 0 blocks</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">==382643==    still reachable: 0 bytes in 0 blocks</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">==382643==         suppressed: 0 bytes in 0 blocks</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">==382643==</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">==382643== For lists of detected and suppressed errors, rerun with: -s</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">==382643== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)</span></span></code></pre><button type="button" aria-label="复制代码到剪贴板" class="copyButton_Ue-o clean-btn">复制</button></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="how-are-objects-allocated-on-the-heap"></a>对象是如何在堆 (heap) 上被分配的<a class="hash-link" href="#how-are-objects-allocated-on-the-heap" title="标题的直接链接">#</a></h2><p>为了更好地理解内存泄漏背后的机制，我们需要了解 C++ 是如何分配以及释放内存的。换言之，<code>new</code> 与 <code>delete</code> 是如何工作的。让我们一起深入进 GNU 的 <code>libstdc++</code> 实现（g++ 默认使用的库）的源码。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="how-new-and-delete-works"></a><code>new</code> 与 <code>delete</code> 是如何工作的<a class="hash-link" href="#how-new-and-delete-works" title="标题的直接链接">#</a></h3><div class="admonition admonition-info alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>info</h5></div><div class="admonition-content"><p>因为 <code>new</code> 与 <code>delete</code> 操作符仅仅是 C++ 标准中定义的 interface，它们拥有不同的实现。我在此处将使用 GNU 在 gcc 11.2 版本中提供的 <code>libstdc++</code> 的 <a href="https://github.com/gcc-mirror/gcc/tree/releases/gcc-11.2.0" target="_blank" rel="noopener noreferrer">源码</a>。</p></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_31ik" id="new-and-delete-are-just-wrappers-of-new-and-delete"></a><code>new[]</code> 和 <code>delete[]</code> 只是对 <code>new</code> 和 <code>delete</code> 的封装<a class="hash-link" href="#new-and-delete-are-just-wrappers-of-new-and-delete" title="标题的直接链接">#</a></h4><p>有意思的是，从 <code>operator new[]</code> 的实现（<a href="https://github.com/gcc-mirror/gcc/blob/releases/gcc-11.2.0/libstdc++-v3/libsupc++/new_opv.cc#L29-L33" target="_blank" rel="noopener noreferrer">源码</a>）来看，<code>new[]</code> 在 <code>stdlibc++</code> 中只是 <code>new</code> 的一个别名。</p><div class="codeBlockContainer_K1bP"><div style="color:#bfc7d5;background-color:#292d3e" class="codeBlockTitle_eoMF">/libstdc++-v3/libsupc++/new_opv.cc:L29-33</div><div class="codeBlockContent_hGly cpp"><pre tabindex="0" class="prism-code language-cpp codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">_GLIBCXX_WEAK_DEFINITION </span><span class="token keyword" style="font-style:italic">void</span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">operator</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">new</span><span class="token punctuation" style="color:rgb(199, 146, 234)">[</span><span class="token punctuation" style="color:rgb(199, 146, 234)">]</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">std</span><span class="token operator" style="color:rgb(137, 221, 255)">::</span><span class="token plain">size_t sz</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"> </span><span class="token function" style="color:rgb(130, 170, 255)">_GLIBCXX_THROW</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">std</span><span class="token operator" style="color:rgb(137, 221, 255)">::</span><span class="token plain">bad_alloc</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token punctuation" style="color:rgb(199, 146, 234)">{</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token keyword" style="font-style:italic">return</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">::</span><span class="token keyword" style="font-style:italic">operator</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">new</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">sz</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token punctuation" style="color:rgb(199, 146, 234)">}</span></span></code></pre><button type="button" aria-label="复制代码到剪贴板" class="copyButton_Ue-o clean-btn">复制</button></div></div><p>对 <code>delete[]</code>（<a href="https://github.com/gcc-mirror/gcc/blob/releases/gcc-11.2.0/libstdc++-v3/libsupc++/del_opv.cc#L32-L36" target="_blank" rel="noopener noreferrer">源码</a>）而言亦是如此，它不过是 <code>delete</code> 的别名。</p><div class="admonition admonition-caution alert alert--warning"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"></path></svg></span>caution</h5></div><div class="admonition-content"><p>根据 GNU stdlibc++ 的实现来看，似乎混合使用 <code>new[]</code> 与 <code>new</code>，以及 <code>delete[]</code> 与 <code>delete</code> 是完全可以接受的。</p><p>但是，你应当避免这么做，因为这种行为是取决于实现的。根据 <a href="https://timsong-cpp.github.io/cppwp/expr.delete#2" target="_blank" rel="noopener noreferrer">C++ Working Paper</a>，使用 <code>new</code> 和 <code>delete</code> 而不是 <code>new[]</code> 和 <code>delete[]</code> 会导致未定义的行为，这会使调试变得一团糟。</p></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_31ik" id="and-new--delete-are-wrappers-of-malloc-and-free"></a>而 <code>new</code> 和 <code>delete</code> 不过是对 <code>malloc</code> 和 <code>free</code> 的封装<a class="hash-link" href="#and-new--delete-are-wrappers-of-malloc-and-free" title="标题的直接链接">#</a></h4><p>让我们接下来看看 <code>new</code> 的 <a href="https://github.com/gcc-mirror/gcc/blob/releases/gcc-11.2.0/libstdc++-v3/libsupc++/new_op.cc#L41-L59" target="_blank" rel="noopener noreferrer">源码</a>。它也只是一个对 C 中的 <code>malloc</code> 加上一些错误处理的封装，并会在最后给调用者 return 一个 <code>malloc</code> 返回的原始指针。</p><div class="codeBlockContainer_K1bP"><div style="color:#bfc7d5;background-color:#292d3e" class="codeBlockTitle_eoMF">/libstdc++-v3/libsupc++/new_op.cc:L41-59</div><div class="codeBlockContent_hGly cpp"><pre tabindex="0" class="prism-code language-cpp codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">_GLIBCXX_WEAK_DEFINITION </span><span class="token keyword" style="font-style:italic">void</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">operator</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">new</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">std</span><span class="token operator" style="color:rgb(137, 221, 255)">::</span><span class="token plain">size_t sz</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"> </span><span class="token function" style="color:rgb(130, 170, 255)">_GLIBCXX_THROW</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">std</span><span class="token operator" style="color:rgb(137, 221, 255)">::</span><span class="token plain">bad_alloc</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token punctuation" style="color:rgb(199, 146, 234)">{</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token keyword" style="font-style:italic">void</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token plain">p</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">/* malloc (0) is unpredictable; avoid it.  */</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token keyword" style="font-style:italic">if</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token function" style="color:rgb(130, 170, 255)">__builtin_expect</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">sz </span><span class="token operator" style="color:rgb(137, 221, 255)">==</span><span class="token plain"> </span><span class="token number" style="color:rgb(247, 140, 108)">0</span><span class="token punctuation" style="color:rgb(199, 146, 234)">,</span><span class="token plain"> </span><span class="token boolean" style="color:rgb(255, 88, 116)">false</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    sz </span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token plain"> </span><span class="token number" style="color:rgb(247, 140, 108)">1</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token keyword" style="font-style:italic">while</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">p </span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token plain"> </span><span class="token function" style="color:rgb(130, 170, 255)">malloc</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">sz</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">==</span><span class="token plain"> </span><span class="token number" style="color:rgb(247, 140, 108)">0</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token punctuation" style="color:rgb(199, 146, 234)">{</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">      new_handler handler </span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token plain"> std</span><span class="token operator" style="color:rgb(137, 221, 255)">::</span><span class="token function" style="color:rgb(130, 170, 255)">get_new_handler</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">      </span><span class="token keyword" style="font-style:italic">if</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token operator" style="color:rgb(137, 221, 255)">!</span><span class="token plain"> handler</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token function" style="color:rgb(130, 170, 255)">_GLIBCXX_THROW_OR_ABORT</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token function" style="color:rgb(130, 170, 255)">bad_alloc</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">      </span><span class="token function" style="color:rgb(130, 170, 255)">handler</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token punctuation" style="color:rgb(199, 146, 234)">}</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token keyword" style="font-style:italic">return</span><span class="token plain"> p</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token punctuation" style="color:rgb(199, 146, 234)">}</span></span></code></pre><button type="button" aria-label="复制代码到剪贴板" class="copyButton_Ue-o clean-btn">复制</button></div></div><p><code>delete</code>（<a href="https://github.com/gcc-mirror/gcc/blob/releases/gcc-11.2.0/libstdc++-v3/libsupc++/del_op.cc#L46-L50" target="_blank" rel="noopener noreferrer">源码</a>）更加简单，直接调用了 C 中的 <code>free</code>。</p><div class="codeBlockContainer_K1bP"><div style="color:#bfc7d5;background-color:#292d3e" class="codeBlockTitle_eoMF">libstdc++-v3/libsupc++/del_op.cc:L46-50</div><div class="codeBlockContent_hGly cpp"><pre tabindex="0" class="prism-code language-cpp codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">_GLIBCXX_WEAK_DEFINITION </span><span class="token keyword" style="font-style:italic">void</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">operator</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">delete</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token keyword" style="font-style:italic">void</span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token plain"> ptr</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">noexcept</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token punctuation" style="color:rgb(199, 146, 234)">{</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  std</span><span class="token operator" style="color:rgb(137, 221, 255)">::</span><span class="token function" style="color:rgb(130, 170, 255)">free</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">ptr</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token punctuation" style="color:rgb(199, 146, 234)">}</span></span></code></pre><button type="button" aria-label="复制代码到剪贴板" class="copyButton_Ue-o clean-btn">复制</button></div></div><p>这样一来，我们似乎需要一路深入到 C 标准库中对 <code>malloc</code> 与 <code>free</code> 的实现才能知道在数组的创建与销毁背后究竟发生了什么。</p><p>然而，我们不会涵盖与 <code>malloc</code> 相关的全部内容（这些内容本身就足够撑起另外一篇文章了），我们将主要关注 <code>malloc</code> 如何组织它分配的内存空间（答案：在堆上构建 <code>malloc_chunk</code>）以及 <code>free</code> 是如何知道去释放哪块内存的。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="how-are-malloc_chunks-structured"></a><code>malloc_chunk</code> 的结构是什么样的?<a class="hash-link" href="#how-are-malloc_chunks-structured" title="标题的直接链接">#</a></h3><div class="admonition admonition-info alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>info</h5></div><div class="admonition-content"><p>与上节一样，我将使用 GNU 对 C 标准库的实现, 即 <code>glibc</code>。
glibc 的当前版本是在 2021 年 8 月 2 日 release 出的 <a href="https://sourceware.org/git/?p=glibc.git;a=tag;h=refs/tags/glibc-2.34" target="_blank" rel="noopener noreferrer">glibc 2.34</a>。</p></div></div><p>以下内容来自 glibc 中 <code>malloc/malloc.c</code> 的注释（<a href="https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=e065785af77af72c17c773517c15b248b067b4ad;hb=ae37d06c7d127817ba43850f0f898b793d42aea7#l1168" target="_blank" rel="noopener noreferrer">源码</a>）。以下内容为英文原文，我可能会在之后某个时候考虑将其翻译为中文。我在原文之上进行了一些微小的编辑以将其适配为 Markdown 格式（本网站使用的格式化工具）。</p><blockquote><p>(The following includes lightly edited explanations by Colin Plumb.)</p><p>Chunks of memory are maintained using a `boundary tag&#x27; method as
described in e.g., Knuth or Standish. (See the paper by Paul
Wilson <a href="ftp://ftp.cs.utexas.edu/pub/garbage/allocsrv.ps" target="_blank" rel="noopener noreferrer">ftp://ftp.cs.utexas.edu/pub/garbage/allocsrv.ps</a> for a
survey of such techniques.) Sizes of free chunks are stored both
in the front of each chunk and at the end. This makes
consolidating fragmented chunks into bigger chunks very fast. The
size fields also hold bits representing whether chunks are free or
in use.</p><p>An allocated chunk looks like this:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">    chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            |             Size of previous chunk, if unallocated (P clear)  |</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            |             Size of chunk, in bytes                     |A|M|P|</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">      mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            |             User data starts here...                          .</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            .                                                               .</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            .             (malloc_usable_size() bytes)                      .</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            .                                                               |</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            |             (size of chunk, but used for application data)    |</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            |             Size of next chunk, in bytes                |A|0|1|</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span></code></pre><button type="button" aria-label="复制代码到剪贴板" class="copyButton_Ue-o clean-btn">复制</button></div></div><p>Where &quot;chunk&quot; is the front of the chunk for the purpose of most of
the malloc code, but &quot;mem&quot; is the pointer that is returned to the
user. &quot;Nextchunk&quot; is the beginning of the next contiguous chunk.</p><p>Chunks always begin on even word boundaries, so the mem portion
(which is returned to the user) is also on an even word boundary, and
thus at least double-word aligned.</p><p>Free chunks are stored in circular doubly-linked lists, and look like this:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">    chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            |             Size of previous chunk, if unallocated (P clear)  |</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    `head:&#x27; |             Size of chunk, in bytes                     |A|0|P|</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">      mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            |             Forward pointer to next chunk in list             |</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            |             Back pointer to previous chunk in list            |</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            |             Unused space (may be 0 bytes long)                .</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            .                                                               .</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            .                                                               |</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    `foot:&#x27; |             Size of chunk, in bytes                           |</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            |             Size of next chunk, in bytes                |A|0|0|</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span></code></pre><button type="button" aria-label="复制代码到剪贴板" class="copyButton_Ue-o clean-btn">复制</button></div></div><p>The P (<code>PREV_INUSE</code>) bit, stored in the unused low-order bit of the
chunk size (which is always a multiple of two words), is an in-use
bit for the <em>previous</em> chunk. If that bit is <em>clear</em>, then the
word before the current chunk size contains the previous chunk
size, and can be used to find the front of the previous chunk.
The very first chunk allocated always has this bit set,
preventing access to non-existent (or non-owned) memory. If
<code>prev_inuse</code> is set for any given chunk, then you CANNOT determine
the size of the previous chunk, and might even get a memory
addressing fault when trying to do so.</p><p>[...]</p><p>Note that the <code>foot</code> of the current chunk is actually represented
as the <code>prev_size</code> of the NEXT chunk. This makes it easier to
deal with alignments etc but can be very confusing when trying
to extend or adapt this code.</p><p>[...]</p></blockquote><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="a-verification-using-poc"></a>利用 PoC 代码的验证<a class="hash-link" href="#a-verification-using-poc" title="标题的直接链接">#</a></h3><p>现在我们将使用 <code>gdb</code> 打印出内存区域并验证以上的解释在我们的代码中是如何工作的。这里我将使用 <a href="https://gef.readthedocs.io/en/master/commands/heap/#heap-chunk-command" target="_blank" rel="noopener noreferrer">GEF</a> 的 <code>heap</code> 功能来更好地显示 <code>malloc</code> 分配的 chunk 的属性。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">gef➤  heap chunk arr</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">Chunk(addr=0x55555556aeb0, size=0x30, flags=PREV_INUSE)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">Chunk size: 48 (0x30)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">Usable size: 40 (0x28)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">Previous chunk size: 0 (0x0)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">PREV_INUSE flag: On</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">IS_MMAPPED flag: Off</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">NON_MAIN_ARENA flag: Off</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">gef➤  x/16xw 0x55555556aeb0-16</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">0x55555556aea0: 0x00000000  0x00000000  0x00000031  0x00000000</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">0x55555556aeb0: 0x44434241  0x48474645  0x4c4b4a49  0x504f4e4d</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">0x55555556aec0: 0x54535251  0x58575655  0x00005a59  0x00000000</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">0x55555556aed0: 0x00000000  0x00000000  0x0000f131  0x00000000</span></span></code></pre><button type="button" aria-label="复制代码到剪贴板" class="copyButton_Ue-o clean-btn">复制</button></div></div><p>值得注意的是，chunk 的大小是 48 字节，可用大小（实际存储用户内容的区域）为 40 字节，要远远大出我们所请求的（26 个字符的数组，应当占据 26 字节的空间）。这是因为 “chunk 永远开始于双数 字（word）的边界……因此至少是双字对齐的”<sup id="fnref-1"><a href="#fn-1" class="footnote-ref">1</a></sup></p><div class="admonition admonition-info alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>info</h5></div><div class="admonition-content"><p>一个 <a href="https://zh.wikipedia.org/zh-cn/%E5%AD%97_(%E8%AE%A1%E7%AE%97%E6%9C%BA)" target="_blank" rel="noopener noreferrer">字（word）</a> 的大小是取决于系统架构的。一般而言，64 位系统的字长为 64 比特，也就是 8 字节。然而，在 <code>gdb</code> 的 <code>x/w</code> 命令中，字长为固定的 32 比特（4 字节），非常令人迷惑。因此，我将使用“字”代指现实中的取决于系统的可变长度的字，而使用“32 比特字”代指 <code>gdb</code> 中的字。</p></div></div><p>因为内存中的 chunk 永远是双字对齐的，我们应该从地址中减去 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>×</mo><mn>8</mn><mo>=</mo><mn>16</mn></mrow><annotation encoding="application/x-tex">2\times8=16</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em"></span><span class="mord">8</span><span class="mspace" style="margin-right:0.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em"></span><span class="mord">1</span><span class="mord">6</span></span></span></span></span> 字节来获得指向 <code>chunk</code> 的指针地址。这里的第一个字（在 gdb 中显示为两个 32 比特字）被 <code>0x00</code> 填满了；并且将在 <code>P</code> flag 被复位时填入上一个 chunk 的大小。</p><p>第二个字 <code>0x31</code>（或是 <code>0b110001</code>）存储了该 chunk 的大小以及 3 个 flag。最低有效位（LSB）<code>0b1</code> 代表 flag <code>P</code> (PREV_INUSE) 被设置了，因此上一个 chunk 还未被释放。因为所有 chunk 的大小都必须至少是 8 字节的整数倍，因此其大小的 3 个最低有效位都必定为 0，这也是为什么这三位 LSB 能被用作 flag。在计算 chunk 大小时，我们能够直接丢弃三位 LSB 并取得 <code>0b110000</code>（<code>0x30</code>，或是 48）字节。</p><div class="admonition admonition-note alert alert--secondary"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"></path></svg></span>note</h5></div><div class="admonition-content"><p>如果你足够仔细的话，你可能已经发现了：chunk 的可用大小是 40 字节，只比 chunk 大小小了 8 字节（而不是 16），也就是一个字。</p><p>这是因为 <code>chunk</code> 指针 “指向的并不是本 chunk 的开始，而是上一 chunk 的最后一字”<sup id="fnref-2"><a href="#fn-2" class="footnote-ref">2</a></sup>（<a href="https://sourceware.org/glibc/wiki/MallocInternals#What_is_a_Chunk.3F" target="_blank" rel="noopener noreferrer">来源</a>）。实际上，chunk 开始于 <code>chunk</code> 指针指向的后一个字（也就是存储 chunk 大小的字）。</p></div></div><p>也就是说，我们 “实际的” chunk 开始于内存地址 <code>0x55555556aea8</code> 并结束于 <code>0x55555556aec8</code>。数据区域开始于 <code>0x55555556aeb0</code> 并结束于 <code>0x55555556aec8</code>。同理，下一个 <code>chunk</code> 指针指向的是本 chunk 的数据区域的最后一个字（<code>0x55555556aec8</code>）。</p><p>既然如此，为什么 chunk 指针会令人迷惑地指向前一 chunk 的最后一字呢？答案与 <code>free</code> 设计的理念有关。</p><p>当前一个 chunk 被 free 时，它会把最后一字填充为它的大小，并清除下一个 chunk（本 chunk）中的 P flag。这样，本 chunk 就可以通过这个大小在前一 chunk 被释放后 “找到前一 chunk 的起始位置” <sup id="fnref-3"><a href="#fn-3" class="footnote-ref">3</a></sup>。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="how-does-free-work"></a><code>free</code> 是如何工作的？<a class="hash-link" href="#how-does-free-work" title="标题的直接链接">#</a></h3><p>到现在，你应该已经知道 “<code>delete[]</code> 如何知道它需要释放哪块内存？” 的答案了：因为这个 chunk 的大小就被存储在它的元数据中。</p><p>但是，还是有一些细节值得我们进行探讨：为什么 chunk 指针要指向上一 chunk 的结尾？我们为什么需要 <code>PREV_INUSE</code> (P) flag？为了解答这些疑问，我们需要了解 <code>free</code> 是如何工作的。</p><div class="admonition admonition-note alert alert--secondary"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"></path></svg></span>note</h5></div><div class="admonition-content"><p>在阅读本节时，你可以与 <a href="#how-are-malloc_chunks-structured"><code>malloc_chunk</code> 的结构是什么样的?</a> 节进行交叉对照，以查看 chunk 在 <code>free</code> 前后的结构分别是什么样子的。</p></div></div><p>长话短说，<code>free</code> 大致是如下工作的。当它被调用时（<a href="https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=e065785af77af72c17c773517c15b248b067b4ad;hb=ae37d06c7d127817ba43850f0f898b793d42aea7#l3237" target="_blank" rel="noopener noreferrer">源码</a>），用户会传给它一个指向数据地址的指针。<code>free</code> 则会调用 <code>mem2chunk</code>（<a href="https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=e065785af77af72c17c773517c15b248b067b4ad;hb=ae37d06c7d127817ba43850f0f898b793d42aea7#l1310" target="_blank" rel="noopener noreferrer">源码</a>）将其转换为指向 chunk 头的指针。
随后，如果这一 chunk 是被 <code>mmap</code> 分配的（可由 M flag 得知），<code>free</code> 会调用 <code>munmap</code>（<a href="https://man.archlinux.org/man/munmap.3p.en" target="_blank" rel="noopener noreferrer">man 3p</a> | <a href="https://man.archlinux.org/man/munmap.2.en" target="_blank" rel="noopener noreferrer">man 2</a>）进行释放；如果不是，它会将 chunk 指针传给 <code>_int_free</code>（<a href="https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=e065785af77af72c17c773517c15b248b067b4ad;hb=ae37d06c7d127817ba43850f0f898b793d42aea7#l4302" target="_blank" rel="noopener noreferrer">源码</a>）正式进行释放。</p><p>然而， <code>free</code> 一个 chunk “并不会将其交还操作系统以给其他程序使用。<code>free()</code> 调用仅仅是将这块内存标记为 ‘可被本程序重新使用’，但对于操作系统而言，这块内存仍然 ‘属于’ 应用程序”<sup id="fnref-4"><a href="#fn-4" class="footnote-ref">4</a></sup>（<a href="https://sourceware.org/glibc/wiki/MallocInternals#Free_Algorithm" target="_blank" rel="noopener noreferrer">来源</a>）的堆上。也就是说，堆管理器仍然需要追踪这块内存，并在合适的时候重新使用它。</p><p>这就是为什么我们使用了一个循环链表来组织被 <code>free</code> 的 chunk 们，其中每一个 chunk 都存储了指向前一个与后一个 chunk 的指针。此外，每个 chunk 的大小会被存储在它内存的最后一个字，即下一个 chunk 的 <code>chunk</code> 指针。这样一来，下一个 chunk 可以利用这一大小访问这个被 <code>free</code> 的 chunk 以及它的 header。当下一个 chunk 也被 <code>free</code> 时，我们能够利用这一属性来 合并（<a href="https://cs.stackexchange.com/a/18234" target="_blank" rel="noopener noreferrer">coalesce</a>）这两个 chunk。</p><p>当然了，实际的 <code>free</code> 操作要远比这复杂，且 chunk 们也会为了更高效的再分配（reallocation）被放置到不同的 bin 中。 你可以阅读官方的 <a href="https://sourceware.org/glibc/wiki/MallocInternals" target="_blank" rel="noopener noreferrer">glibc wiki</a>，这篇更为详细的 <a href="https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/" target="_blank" rel="noopener noreferrer">博文</a>，或是 <a href="https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=e065785af77af72c17c773517c15b248b067b4ad;hb=ae37d06c7d127817ba43850f0f898b793d42aea7#l4302" target="_blank" rel="noopener noreferrer"><code>_int_free</code> 的源码</a> 以了解更多底层细节。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="how-can-we-prevent-memory-leaks"></a>我们如何预防内存泄漏？<a class="hash-link" href="#how-can-we-prevent-memory-leaks" title="标题的直接链接">#</a></h2><p>现在可能是时候回到我们开始的主题了：既然我们已经知道了内存泄漏是什么，以及它们是如何发生的，那么我们有什么办法预防内存泄漏吗？</p><ol><li>永远 <code>delete</code> (<code>delete[]</code>) 使用 <code>new</code> (<code>new[]</code>) 创建的对象<ul><li>这是我们能做的最简单的事情，如果你仍然坚持使用 <code>new</code> 的话</li></ul></li><li>避免直接调用 <code>new</code> 与 <code>delete</code><ul><li><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#r11-avoid-calling-new-and-delete-explicitly" target="_blank" rel="noopener noreferrer">说明</a>（英语）</li><li><strong>太长不看</strong>：使用资源句柄（resource handle）而不是裸指针，后者具有泄漏的可能性。</li><li>解决方法：使用诸如 <code>unique_ptr</code> 与 <code>shared_ptr</code> 的智能指针。</li></ul></li><li>不要用裸指针（<code>T*</code>）或引用（<code>T&amp;</code>）来转移所有权（ownership）<ul><li><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#i11-never-transfer-ownership-by-a-raw-pointer-t-or-reference-t" target="_blank" rel="noopener noreferrer">说明</a>（英语）</li><li><strong>太长不看</strong>：容易产生“谁应当删除指针”的歧义。</li><li>解决方法：直接 return 对象本身，或是使用智能指针。</li></ul></li></ol><p>一般来说，要求程序员手动释放资源是很容易出错的。你应该考虑 <a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-raii" target="_blank" rel="noopener noreferrer">使用资源句柄和 RAII（资源获取即初始化）自动管理资源</a>（英语）。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="references--further-readings"></a>引用 &amp; 扩展阅读<a class="hash-link" href="#references--further-readings" title="标题的直接链接">#</a></h2><ul><li>Stroustrup, Bjarne and Sutter, Herb. <a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines" target="_blank" rel="noopener noreferrer">&quot;C++ Core Guidelines&quot;</a>. Updated Jun 17, 2021. Accessed Aug 08, 2021.</li><li>glibc wiki. <a href="https://sourceware.org/glibc/wiki/MallocInternals" target="_blank" rel="noopener noreferrer">&quot;MallocInternals&quot;</a>. Updated May 20, 2019. Accessed Aug 08, 2021.</li><li>Azeria Labs. <a href="https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/" target="_blank" rel="noopener noreferrer">&quot;Heap Exploitation Part 2: Understanding the Glibc Heap Implementation&quot;</a>. Accessed Aug 08, 2021.</li><li>CTF Wiki. <a href="https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/heap-structure/" target="_blank" rel="noopener noreferrer">&quot;堆相关数据结构&quot;</a> (in Chinese). Accessed Aug 10, 2021.</li><li>glibc Contributors. <a href="https://sourceware.org/git/?p=glibc.git;a=tree;h=6eb9f63e6c9197e967a8cc12a8b235335e5a873d;hb=ae37d06c7d127817ba43850f0f898b793d42aea7" target="_blank" rel="noopener noreferrer">glibc v2.34 source code</a>. Aug 2, 2021. Accessed Aug 8, 2021.</li><li>gcc Contributors. <a href="https://github.com/gcc-mirror/gcc/tree/releases/gcc-11.2.0" target="_blank" rel="noopener noreferrer">gcc v11.2.0 source code</a>. Jul 28, 2021. Accessed Aug 8, 2021.</li><li>StackOverflow. <a href="https://stackoverflow.com/questions/197675/how-does-delete-know-the-size-of-the-operand-array" target="_blank" rel="noopener noreferrer">&quot;How does delete[] know the size of the operand array?&quot;</a></li></ul><p>顺带一提，在搜索内存泄漏的时候，我在 Brookhaven National Lab 的域名下面发现了一个 大亚湾反应堆中微子实验的 wiki 页面 <a href="https://wiki.bnl.gov/dayabay/index.php?title=Dealing_With_Memory_Leaks" target="_blank" rel="noopener noreferrer">&quot;Dealing With Memory Leaks&quot;</a>。我都不知道大亚湾反应堆还有一个国际研究项目 😂</p><div class="footnotes"><hr><ol><li id="fn-1">&quot;chunks always begin on even word boundaries ... and thus at least double-word aligned.&quot;<a href="#fnref-1" class="footnote-backref">↩</a></li><li id="fn-2">&quot;does not point to the beginning of the chunk, but to the last word in the previous chunk&quot;（<a href="https://sourceware.org/glibc/wiki/MallocInternals#What_is_a_Chunk.3F" target="_blank" rel="noopener noreferrer">来源</a>）<a href="#fnref-2" class="footnote-backref">↩</a></li><li id="fn-3">&quot;to find the front of the previous chunk&quot;<a href="#fnref-3" class="footnote-backref">↩</a></li><li id="fn-4">&quot;does not actually return it to the operating system for other applications to use. The <code>free()</code> call marks a chunk of memory as &#x27;free to be reused&#x27; by the application, but from the operating system&#x27;s point of view, the memory still &#x27;belongs&#x27; to the application&quot;（<a href="https://sourceware.org/glibc/wiki/MallocInternals#Free_Algorithm" target="_blank" rel="noopener noreferrer">来源</a>）<a href="#fnref-4" class="footnote-backref">↩</a></li></ol></div></div><footer class="row docusaurus-mt-lg blogPostDetailsFull_3kfx"><div class="col"><b>标签：</b><ul class="tags_2ga9 padding--none margin-left--sm"><li class="tag_11ep"><a class="tag_1Okp tagRegular_3MiF" href="/zh-Hans/blog/tags/c">c++</a></li><li class="tag_11ep"><a class="tag_1Okp tagRegular_3MiF" href="/zh-Hans/blog/tags/pwn">pwn</a></li></ul></div><div class="col margin-top--sm"><a href="https://github.com/yechs/website/edit/master/blog/blog/2021-08-13-malloc_chunks.mdx" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_2_ui" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>编辑此页</a></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="博文分页导航"><div class="pagination-nav__item"></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/zh-Hans/blog/welcome"><div class="pagination-nav__sublabel">较旧一篇</div><div class="pagination-nav__label">Me and My Broken Site(s) »</div></a></div></nav></main><div class="col col--2"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#how-it-all-started" class="table-of-contents__link">我为什么写这篇文章</a></li><li><a href="#what-are-memory-leaks" class="table-of-contents__link">什么是内存泄漏</a><ul><li><a href="#poc" class="table-of-contents__link">PoC</a></li><li><a href="#a-deeper-look-into-the-memory" class="table-of-contents__link">初探内存</a></li><li><a href="#verification-with-valgrind" class="table-of-contents__link">利用 Valgrind 进行验证</a></li></ul></li><li><a href="#how-are-objects-allocated-on-the-heap" class="table-of-contents__link">对象是如何在堆 (heap) 上被分配的</a><ul><li><a href="#how-new-and-delete-works" class="table-of-contents__link"><code>new</code> 与 <code>delete</code> 是如何工作的</a></li><li><a href="#how-are-malloc_chunks-structured" class="table-of-contents__link"><code>malloc_chunk</code> 的结构是什么样的?</a></li><li><a href="#a-verification-using-poc" class="table-of-contents__link">利用 PoC 代码的验证</a></li><li><a href="#how-does-free-work" class="table-of-contents__link"><code>free</code> 是如何工作的？</a></li></ul></li><li><a href="#how-can-we-prevent-memory-leaks" class="table-of-contents__link">我们如何预防内存泄漏？</a></li><li><a href="#references--further-readings" class="table-of-contents__link">引用 &amp; 扩展阅读</a></li></ul></div></div></div></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">本站</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/zh-Hans/kb/intro">Knowledge Base</a></li><li class="footer__item"><a class="footer__link-item" href="/zh-Hans/blog">Blog</a></li></ul></div><div class="col footer__col"><div class="footer__title">与我联系</div><ul class="footer__items"><li class="footer__item"><a href="https://github.com/yechs" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="footer__item"><a href="https://www.linkedin.com/in/yechs/" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>LinkedIn<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div><div class="col footer__col"><div class="footer__title">更多</div><ul class="footer__items"><li class="footer__item"><a href="https://wso.williams.edu/" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Williams Students Online<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="footer__item"><a href="https://computerization.io/" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Computerization<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="footer__item"><a href="https://0x194.com" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Team 0x194<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">权利所有 © 2021 Ye Shu。保留部分权利。</div></div></div></footer></div>
<script src="/zh-Hans/assets/js/runtime~main.02f4c884.js"></script>
<script src="/zh-Hans/assets/js/main.2b80505b.js"></script>
</body>
</html>