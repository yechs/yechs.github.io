"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[123],{3356:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>i,contentTitle:()=>a,default:()=>u,frontMatter:()=>s,metadata:()=>l,toc:()=>h});var n=o(5893),r=o(1151);const s={slug:"malloc_chunk",title:"Memory Leak & malloc chunks",author:"Ye Shu",author_title:"Studying how C++ allocates and frees chunks in memory",author_url:"https://github.com/yechs",author_image_url:"https://avatars.githubusercontent.com/u/49149993",image:"https://shuye.dev/img/yechs.jpeg",tags:["c++","pwn"]},a="Memory Leak & malloc chunks",l={permalink:"/blog/malloc_chunk",editUrl:"https://github.com/yechs/website/edit/master/blog/blog/2021-08-13-malloc_chunks.mdx",source:"@site/blog/2021-08-13-malloc_chunks.mdx",title:"Memory Leak & malloc chunks",description:"How it all started",date:"2021-08-13T00:00:00.000Z",formattedDate:"August 13, 2021",tags:[{label:"c++",permalink:"/blog/tags/c"},{label:"pwn",permalink:"/blog/tags/pwn"}],readingTime:16.47,hasTruncateMarker:!0,authors:[{name:"Ye Shu",title:"Studying how C++ allocates and frees chunks in memory",url:"https://github.com/yechs",imageURL:"https://avatars.githubusercontent.com/u/49149993"}],frontMatter:{slug:"malloc_chunk",title:"Memory Leak & malloc chunks",author:"Ye Shu",author_title:"Studying how C++ allocates and frees chunks in memory",author_url:"https://github.com/yechs",author_image_url:"https://avatars.githubusercontent.com/u/49149993",image:"https://shuye.dev/img/yechs.jpeg",tags:["c++","pwn"]},unlisted:!1,nextItem:{title:"Me and My Broken Site(s)",permalink:"/blog/welcome"}},i={authorsImageUrls:[void 0]},h=[{value:"How it all started",id:"how-it-all-started",level:2}];function c(e){const t={a:"a",code:"code",h2:"h2",li:"li",ol:"ol",p:"p",...(0,r.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h2,{id:"how-it-all-started",children:"How it all started"}),"\n",(0,n.jsxs)(t.p,{children:["While debugging a memory leak bug during my summer internship, I found out that one of our APIs returned a raw pointer and thus transferred its ownership to the caller (me). In other words, I'm now responsible of ",(0,n.jsx)(t.code,{children:"delete"}),"-ing the pointer after my code finishes. While this is ",(0,n.jsx)(t.a,{href:"https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#i11-never-transfer-ownership-by-a-raw-pointer-t-or-reference-t",children:"a terrible engineering practice"}),", I grew interested in how memory leaks happen, and how ",(0,n.jsx)(t.code,{children:"delete[]"})," solves the problem."]}),"\n",(0,n.jsx)(t.p,{children:"After some research & experiments, I wrote this blog post, which hopefully addresses three sets of questions"}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsx)(t.li,{children:"What are memory leaks?"}),"\n",(0,n.jsxs)(t.li,{children:["How are objects allocated on the heap? How does ",(0,n.jsx)(t.code,{children:"delete[]"})," know which area of memory to be freed?"]}),"\n",(0,n.jsx)(t.li,{children:"How can we prevent memory leaks from happening?"}),"\n"]})]})}function u(e={}){const{wrapper:t}={...(0,r.a)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(c,{...e})}):c(e)}},1151:(e,t,o)=>{o.d(t,{Z:()=>l,a:()=>a});var n=o(7294);const r={},s=n.createContext(r);function a(e){const t=n.useContext(s);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),n.createElement(s.Provider,{value:t},e.children)}}}]);