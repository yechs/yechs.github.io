"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[477],{10:function(e){e.exports=JSON.parse('{"blogPosts":[{"id":"malloc_chunk","metadata":{"permalink":"/blog/malloc_chunk","editUrl":"https://github.com/yechs/website/edit/master/blog/blog/2021-08-13-malloc_chunks.mdx","source":"@site/blog/2021-08-13-malloc_chunks.mdx","title":"Memory Leak & malloc chunks","description":"How it all started","date":"2021-08-13T00:00:00.000Z","formattedDate":"August 13, 2021","tags":[{"label":"c++","permalink":"/blog/tags/c"},{"label":"pwn","permalink":"/blog/tags/pwn"}],"readingTime":16.47,"truncated":true,"authors":[{"name":"Ye Shu","title":"Studying how C++ allocates and frees chunks in memory","url":"https://github.com/yechs","imageURL":"https://avatars.githubusercontent.com/u/49149993"}],"nextItem":{"title":"Me and My Broken Site(s)","permalink":"/blog/welcome"}},"content":"## How it all started {#how-it-all-started}\\n\\nWhile debugging a memory leak bug during my summer internship, I found out that one of our APIs returned a raw pointer and thus transferred its ownership to the caller (me). In other words, I\'m now responsible of `delete`-ing the pointer after my code finishes. While this is [a terrible engineering practice](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#i11-never-transfer-ownership-by-a-raw-pointer-t-or-reference-t), I grew interested in how memory leaks happen, and how `delete[]` solves the problem.\\n\\nAfter some research & experiments, I wrote this blog post, which hopefully addresses three sets of questions\\n\\n1. What are memory leaks?\\n2. How are objects allocated on the heap? How does `delete[]` know which area of memory to be freed?\\n3. How can we prevent memory leaks from happening?\\n\\n\x3c!--truncate--\x3e\\n\\nWhile the Stack Overflow question [\\"How does delete[] \'know\' the size of the operand array?\\"](https://stackoverflow.com/questions/197675/how-does-delete-know-the-size-of-the-operand-array) sort of answers the second question, I decide to dig deeper into the actual memory area.\\n\\nCoincidentally, I have worked on a heap exploitation problem with my friend [@gzhding](https://guozhen.dev) in a past CTF event. Thanks to the experience, I learned how to use `gdb` to dump the heap memory and gain some insight into the problem.\\n\\nimport TOCCollapsible from \'@theme/TOCCollapsible\';\\n\\n<TOCCollapsible toc={toc} />\\n\\n## What are Memory Leaks? {#what-are-memory-leaks}\\n\\nWe know that [C++ can dynamically allocate memory on the heap](https://www.cplusplus.com/doc/tutorial/dynamic/). A common example is to use `new[]` to create an array and `delete[]` to remove it.\\n\\n[Memory leaks](https://en.wikipedia.org/wiki/Memory_leak) happens when we create an array in the memory (_i.e._ \\"allocates\\" a segment of memory to store the object) and forget to delete it. When the pointer to the memory goes out of scope, the running code becomes ignorant of the allocated memory area. In worst cases, when the leakage happens in a loop, newly allocated memory will continue to pile up without being released, potentially slowing down or crash the computer.\\n\\n### PoC {#poc}\\n\\nHere is a short Proof of Concept (PoC) code. The `main()` function calls the `memory_leak()` function, which allocates an array of 26 `char`s and fills them with capital English alphabets.\\n\\n```cpp title=\\"memory_leak.cpp\\"\\nvoid memory_leak() {\\n    // Always delete pointers created by new to avoid memory leaks!\\n    char *arr = new char[26];\\n\\n    for (int i = 0; i < 26; i++) {\\n        arr[i] = char(65 + i); // 65 is the ascii of \'A\'\\n    }\\n\\n    // The memory area is not freed!\\n    // delete[] arr;\\n}\\n\\nint main() {\\n    memory_leak();\\n    return 0;\\n}\\n```\\n\\nAs the `delete[]` statement is commented out, when the function `memory_leak()` returns, the pointer `arr` goes out of scope and results in the memory area leaked.\\n\\n### A Deeper Look into the Memory {#a-deeper-look-into-the-memory}\\n\\n:::note\\nInstead of native GDB, I use [GEF](https://github.com/hugsy/gef) (GDB Enhanced Features) for prettified output and some extra features like `heap`.\\n:::\\n\\nLet us compile the program with `g++ -g3 memory_leak.cpp -o memory_leak` (the `-g3` flag preserves debug information during compilation) and use `gdb` to verify the memory leak.\\n\\nWe\'ll add a breakpoint at the end of function `memory_leak()` and run the program until it hits the breakpoint.\\n\\n```console\\n$ gdb memory_leak\\n\\ngef\u27a4  b 11\\nBreakpoint 1 at 0x1179: file memory_leak.cpp, line 11.\\n\\ngef\u27a4  r\\n[...]\\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 source:memory_leak.cpp+11 \u2500\u2500\u2500\u2500\\n      6          arr[i] = char(65 + i); // 65 is the ascii of \'A\'\\n      7      }\\n      8\\n      9      // The memory area is not freed!\\n     10      // delete[] arr;\\n\u25cf\u2192   11  }\\n     12\\n     13  int main() {\\n     14      memory_leak();\\n     15      return 0;\\n     16  }\\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 threads \u2500\u2500\u2500\u2500\\n[#0] Id 1, Name: \\"memory_leak\\", stopped 0x555555555179 in memory_leak (), reason: BREAKPOINT\\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 trace \u2500\u2500\u2500\u2500\\n[#0] 0x555555555179 \u2192 memory_leak()\\n[#1] 0x555555555186 \u2192 main()\\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n\\ngef\u27a4  info locals\\narr = 0x55555556aeb0 \\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\"\\n\\ngef\u27a4  x/8xw 0x55555556aeb0\\n0x55555556aeb0: 0x44434241      0x48474645      0x4c4b4a49      0x504f4e4d\\n0x55555556aec0: 0x54535251      0x58575655      0x00005a59      0x00000000\\n```\\n\\nAfter the program hits the breakpoint, we print out the address of pointer `arr` and the content of that memory. Note that the memory is stored in [little endian](https://en.wikipedia.org/wiki/Little-endian) order, so `0x44` (D) comes before `0x43` (C), `0x42` (B), and finally `0x41` (A).\\n\\nNow, let us continue running the program until `memory_leak()` returns back to `main()`.\\n\\n```gdb\\ngef\u27a4  finish\\n[...]\\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 source:memory_leak.cpp+15 \u2500\u2500\u2500\u2500\\n     10      // delete[] arr;\\n\u25cf    11  }\\n     12\\n     13  int main() {\\n     14      memory_leak();\\n \u2192   15      return 0;\\n     16  }\\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 threads \u2500\u2500\u2500\u2500\\n[#0] Id 1, Name: \\"memory_leak\\", stopped 0x555555555186 in main (), reason: TEMPORARY BREAKPOINT\\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 trace \u2500\u2500\u2500\u2500\\n[#0] 0x555555555186 \u2192 main()\\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n\\ngef\u27a4  info locals\\nNo locals.\\n\\ngef\u27a4  x/8xw 0x55555556aeb0\\n0x55555556aeb0: 0x44434241      0x48474645      0x4c4b4a49      0x504f4e4d\\n0x55555556aec0: 0x54535251      0x58575655      0x00005a59      0x00000000\\n```\\n\\n\x3c!-- gef\u27a4  heap chunks\\nChunk(addr=0x555555559010, size=0x290, flags=PREV_INUSE)\\n    [0x0000555555559010     00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................]\\nChunk(addr=0x5555555592a0, size=0x11c10, flags=PREV_INUSE)\\n    [0x00005555555592a0     00 1c 01 00 00 00 00 00 00 00 00 00 00 00 00 00    ................]\\nChunk(addr=0x55555556aeb0, size=0x30, flags=PREV_INUSE)\\n    [0x000055555556aeb0     41 42 43 44 45 46 47 48 49 4a 4b 4c 4d 4e 4f 50    ABCDEFGHIJKLMNOP]\\nChunk(addr=0x55555556aee0, size=0xf130, flags=PREV_INUSE)  \u2190  top chunk --\x3e\\n\\nNow that `memory_leak()` returns, we have lost the pointer `arr` pointing to the memory address `0x55555556aeb0`. However, as we print out the memory area, the data is still stored in the memory without being released, leading to a memory leak.\\n\\n### Verification with Valgrind {#verification-with-valgrind}\\n\\nFurthermore, we can use automated tools like [Valgrind](https://valgrind.org) to check for memory leaks.\\n\\n```console\\n$ valgrind --leak-check=full ./memory_leak\\n==382643== Memcheck, a memory error detector\\n==382643== Copyright (C) 2002-2017, and GNU GPL\'d, by Julian Seward et al.\\n==382643== Using Valgrind-3.17.0 and LibVEX; rerun with -h for copyright info\\n==382643== Command: ./memory_leak\\n==382643==\\n==382643==\\n==382643== HEAP SUMMARY:\\n==382643==     in use at exit: 26 bytes in 1 blocks\\n==382643==   total heap usage: 2 allocs, 1 frees, 72,730 bytes allocated\\n==382643==\\n==382643== 26 bytes in 1 blocks are definitely lost in loss record 1 of 1\\n==382643==    at 0x484021F: operator new[](unsigned long) (vg_replace_malloc.c:579)\\n==382643==    by 0x10914A: memory_leak() (memory_leak.cpp:3)\\n==382643==    by 0x109185: main (memory_leak.cpp:14)\\n==382643==\\n==382643== LEAK SUMMARY:\\n==382643==    definitely lost: 26 bytes in 1 blocks\\n==382643==    indirectly lost: 0 bytes in 0 blocks\\n==382643==      possibly lost: 0 bytes in 0 blocks\\n==382643==    still reachable: 0 bytes in 0 blocks\\n==382643==         suppressed: 0 bytes in 0 blocks\\n==382643==\\n==382643== For lists of detected and suppressed errors, rerun with: -s\\n==382643== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)\\n```\\n\\n## How are objects allocated on the heap? {#how-are-objects-allocated-on-the-heap}\\n\\nTo understand better the mechanisms behind memory leaks, we need to know how C++ allocates and frees memories, _i.e._ how `new` and `delete` works. Let us dig deeper into the source code of GNU\'s `libstdc++` implementation (the library used by g++ by default).\\n\\n### How `new` and `delete` works {#how-new-and-delete-works}\\n\\n:::info\\nAs `new` and `delete` operators are merely interfaces defined by the C++ standard and have different implementations, here I\'ll use the [source code](https://github.com/gcc-mirror/gcc/tree/releases/gcc-11.2.0) of GNU\'s `libstdc++` that ships with gcc version 11.2.0 for reference.\\n:::\\n\\n#### `new[]` and `delete[]` are just wrappers of `new` and `delete` {#new-and-delete-are-just-wrappers-of-new-and-delete}\\n\\nInterestingly, from the implementation of `operator new[]` ([source](https://github.com/gcc-mirror/gcc/blob/releases/gcc-11.2.0/libstdc++-v3/libsupc++/new_opv.cc#L29-L33)), it seems that in `stdlibc++`, `new[]` is just an alias for `new`.\\n\\n```cpp title=\\"/libstdc++-v3/libsupc++/new_opv.cc:L29-33\\"\\n_GLIBCXX_WEAK_DEFINITION void*\\noperator new[] (std::size_t sz) _GLIBCXX_THROW (std::bad_alloc)\\n{\\n  return ::operator new(sz);\\n}\\n```\\n\\nThe same is true for `delete[]` ([source](https://github.com/gcc-mirror/gcc/blob/releases/gcc-11.2.0/libstdc++-v3/libsupc++/del_opv.cc#L32-L36)), which is just an alias for `delete`.\\n\\n:::caution\\nFrom the implementation of GNU stdlibc++, it seems perfectly ok to mix the use of `new[]` with `new`, and `delete[]` with `delete`.\\n\\nHowever, you should never do this, because this behavior is implementation-specific. Using `new` and `delete` instead of `new[]` and `delete[]` leads to undefined behavior (according to [C++ Working Paper](https://timsong-cpp.github.io/cppwp/expr.delete#2)) and will make your life painful.\\n:::\\n\\n#### And `new` & `delete` are wrappers of `malloc` and `free` {#and-new--delete-are-wrappers-of-malloc-and-free}\\n\\nNow let us take a look at the [source code](https://github.com/gcc-mirror/gcc/blob/releases/gcc-11.2.0/libstdc++-v3/libsupc++/new_op.cc#L41-L59) of `new`. It\'s just a wrapper around C\'s `malloc` plus some error handling and returns the `malloc`-ed raw pointer to the caller.\\n\\n```cpp title=\\"/libstdc++-v3/libsupc++/new_op.cc:L41-59\\"\\n_GLIBCXX_WEAK_DEFINITION void *\\noperator new (std::size_t sz) _GLIBCXX_THROW (std::bad_alloc)\\n{\\n  void *p;\\n\\n  /* malloc (0) is unpredictable; avoid it.  */\\n  if (__builtin_expect (sz == 0, false))\\n    sz = 1;\\n\\n  while ((p = malloc (sz)) == 0)\\n    {\\n      new_handler handler = std::get_new_handler ();\\n      if (! handler)\\n\\t_GLIBCXX_THROW_OR_ABORT(bad_alloc());\\n      handler ();\\n    }\\n\\n  return p;\\n}\\n```\\n\\n`delete` ([source](https://github.com/gcc-mirror/gcc/blob/releases/gcc-11.2.0/libstdc++-v3/libsupc++/del_op.cc#L46-L50)) is even simpler, and just calls C\'s `free`.\\n\\n```cpp title=\\"libstdc++-v3/libsupc++/del_op.cc:L46-50\\"\\n_GLIBCXX_WEAK_DEFINITION void\\noperator delete(void* ptr) noexcept\\n{\\n  std::free(ptr);\\n}\\n```\\n\\n\x3c!-- ### How `malloc` and `free` works --\x3e\\n\\nHence it seems that we should dive all the way into C standard library\'s implementation of `malloc` and `free` and see what exactly is happening behind the creation and deletion of arrays.\\n\\nHowever, instead of covering the full picture of `malloc` (which could fill another blog post), we\'ll be mainly focusing on how `malloc` structures the allocated memory area (answer: using `malloc_chunk`s on the heap) and how `free` knows which area of memory to be released.\\n\\n### How are `malloc_chunk`s structured? {#how-are-malloc_chunks-structured}\\n\\n:::info\\nLike in the previous section, I will use GNU\'s implementation of C standard library, _i.e._ `glibc`.\\nThe current version is [glibc 2.34](https://sourceware.org/git/?p=glibc.git;a=tag;h=refs/tags/glibc-2.34), which is released on Aug 2, 2021.\\n:::\\n\\nThe following content comes from the comments in `malloc/malloc.c` of glibc ([source](https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=e065785af77af72c17c773517c15b248b067b4ad;hb=ae37d06c7d127817ba43850f0f898b793d42aea7#l1168)). I\'ve done some minor edits to adapt the format to Markdown (what this website uses).\\n\\n> (The following includes lightly edited explanations by Colin Plumb.)\\n>\\n> Chunks of memory are maintained using a `boundary tag\' method as\\n> described in e.g., Knuth or Standish. (See the paper by Paul\\n> Wilson [ftp://ftp.cs.utexas.edu/pub/garbage/allocsrv.ps](ftp://ftp.cs.utexas.edu/pub/garbage/allocsrv.ps) for a\\n> survey of such techniques.) Sizes of free chunks are stored both\\n> in the front of each chunk and at the end. This makes\\n> consolidating fragmented chunks into bigger chunks very fast. The\\n> size fields also hold bits representing whether chunks are free or\\n> in use.\\n>\\n> An allocated chunk looks like this:\\n>\\n> ```\\n>     chunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\\n>             |             Size of previous chunk, if unallocated (P clear)  |\\n>             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\\n>             |             Size of chunk, in bytes                     |A|M|P|\\n>       mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\\n>             |             User data starts here...                          .\\n>             .                                                               .\\n>             .             (malloc_usable_size() bytes)                      .\\n>             .                                                               |\\n> nextchunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\\n>             |             (size of chunk, but used for application data)    |\\n>             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\\n>             |             Size of next chunk, in bytes                |A|0|1|\\n>             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\\n> ```\\n>\\n> Where \\"chunk\\" is the front of the chunk for the purpose of most of\\n> the malloc code, but \\"mem\\" is the pointer that is returned to the\\n> user. \\"Nextchunk\\" is the beginning of the next contiguous chunk.\\n>\\n> Chunks always begin on even word boundaries, so the mem portion\\n> (which is returned to the user) is also on an even word boundary, and\\n> thus at least double-word aligned.\\n>\\n> Free chunks are stored in circular doubly-linked lists, and look like this:\\n>\\n> ```\\n>     chunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\\n>             |             Size of previous chunk, if unallocated (P clear)  |\\n>             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\\n>     `head:\' |             Size of chunk, in bytes                     |A|0|P|\\n>       mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\\n>             |             Forward pointer to next chunk in list             |\\n>             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\\n>             |             Back pointer to previous chunk in list            |\\n>             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\\n>             |             Unused space (may be 0 bytes long)                .\\n>             .                                                               .\\n>             .                                                               |\\n> nextchunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\\n>     `foot:\' |             Size of chunk, in bytes                           |\\n>             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\\n>             |             Size of next chunk, in bytes                |A|0|0|\\n>             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\\n> ```\\n>\\n> The P (`PREV_INUSE`) bit, stored in the unused low-order bit of the\\n> chunk size (which is always a multiple of two words), is an in-use\\n> bit for the _previous_ chunk. If that bit is _clear_, then the\\n> word before the current chunk size contains the previous chunk\\n> size, and can be used to find the front of the previous chunk.\\n> The very first chunk allocated always has this bit set,\\n> preventing access to non-existent (or non-owned) memory. If\\n> `prev_inuse` is set for any given chunk, then you CANNOT determine\\n> the size of the previous chunk, and might even get a memory\\n> addressing fault when trying to do so.\\n>\\n> [...]\\n>\\n> Note that the `foot` of the current chunk is actually represented\\n> as the `prev_size` of the NEXT chunk. This makes it easier to\\n> deal with alignments etc but can be very confusing when trying\\n> to extend or adapt this code.\\n>\\n> [...]\\n\\n### A verification using PoC {#a-verification-using-poc}\\n\\nNow we can use `gdb` to actually print out the memory area and see how the explanation above applies to our case. Here I used the `heap` feature introduced by [GEF](https://gef.readthedocs.io/en/master/commands/heap/#heap-chunk-command) to better visualize the `malloc`-ed chunk\'s properties.\\n\\n```\\ngef\u27a4  heap chunk arr\\nChunk(addr=0x55555556aeb0, size=0x30, flags=PREV_INUSE)\\nChunk size: 48 (0x30)\\nUsable size: 40 (0x28)\\nPrevious chunk size: 0 (0x0)\\nPREV_INUSE flag: On\\nIS_MMAPPED flag: Off\\nNON_MAIN_ARENA flag: Off\\n\\ngef\u27a4  x/16xw 0x55555556aeb0-16\\n0x55555556aea0:\\t0x00000000\\t0x00000000\\t0x00000031\\t0x00000000\\n0x55555556aeb0:\\t0x44434241\\t0x48474645\\t0x4c4b4a49\\t0x504f4e4d\\n0x55555556aec0:\\t0x54535251\\t0x58575655\\t0x00005a59\\t0x00000000\\n0x55555556aed0:\\t0x00000000\\t0x00000000\\t0x0000f131\\t0x00000000\\n```\\n\\nNote that here the chunk size is 48 bytes, with the usable size (size of actual user memory area) being 40, which is much higher than what we requested (an array of 26 chars, which should be 26 bytes). This is because \\"chunks always begin on even word boundaries ... and thus at least double-word aligned.\\" (from the blockquote above).\\n\\n:::info\\nThe size of a [word](<https://en.wikipedia.org/wiki/Word_(computer_architecture)>) varies by architecture. For a normal 64 bit system, the word is 64 bit long and thus takes up 8 bytes in size. However, a word in `gdb` `x/w` command has a fixed length of 32 bits (4 bytes), which is a bit confusing. Hence, I\'ll use \\"word\\" to refer to an actual variable-size word, and \\"32-bit word\\" to refer to the `gdb` word.\\n:::\\n\\nSince the chunk in memory is always double-word aligned, we should minus the address by $2\\\\times8=16$ bytes to obtain the `chunk` pointer address. Here the first word (represented by 2 32-bit words as in gdb) is filled with `0x00`, and will be filled with the area of the previous chunk, if the `P` flag in unset.\\n\\nThe second word `0x31` (or `0b110001`) stores the chunk size and 3 flags. The least significant bit `0b1` indicates that the flag `P` (PREV_INUSE) is set, so the previous chunk has not been freed. Since all chunks must have size at least of multiples of 8, the 3 least significant bits of the size field is always 0, which is why the 3 LSBs can be used as flags. To calculate the chunk size, we can discard the 3 LSBs and obtain `0b110000` (`0x30`, or 48) bytes.\\n\\n:::note\\n\\nIf you are cautious enough, you might have noticed that the usable size for the chunk is 40, which is only 8 bytes (not 16), _i.e._ one word, less than the chunk size.\\n\\nThis is because the `chunk` pointer [\\"does not point to the beginning of the chunk, but to the last word in the previous chunk\\"](https://sourceware.org/glibc/wiki/MallocInternals#What_is_a_Chunk.3F). The actual chunk starts at the next word of `chunk` pointer (which stores the sizes).\\n\\n:::\\n\\nSo, our \\"actual\\" chunk starts at the address `0x55555556aea8` and ends at `0x55555556aec8`. The data area starts from `0x55555556aeb0` and ends in `0x55555556aec8`. Similarly, the next `chunk` pointer points to the last word in our chunk\'s data area (`0x55555556aec8`).\\n\\nThen, why does the chunk pointer confusingly points to the last word in the previous chunk? The answer is related to the `free` design mechanism.\\n\\nBecause when the previous chunk is freed, it\'ll fill its last word with its size and clear the `P` flag in its next chunk (ours). Hence, our chunk can use this size \\"to find the front of the previous chunk\\" after the previous chunk has been freed.\\n\\n### How does `free` work? {#how-does-free-work}\\n\\nBy now, you should already have the answer to \\"how does `delete[]` know which area of memory to be freed\\"\u2014because the size of the chunk is stored in its metadata.\\n\\nHowever, there are still some intricacies to be solved: why does the chunk pointer points to the last word in the previous chunk? Why do we need the `PREV_INUSE` (P) flag? To do so, we shall look into how `free` works.\\n\\n:::note\\nWhile reading this section, you can refer back to the section [How are malloc_chunks structured?\\n](#how-are-malloc_chunks-structured) to see how memory chunks look like before and after `free`.\\n:::\\n\\nLong story short, `free` works like the following. When it is called ([source](https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=e065785af77af72c17c773517c15b248b067b4ad;hb=ae37d06c7d127817ba43850f0f898b793d42aea7#l3237)), the user would pass a pointer to the memory area to it, `free` would then call `mem2chunk` ([source](https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=e065785af77af72c17c773517c15b248b067b4ad;hb=ae37d06c7d127817ba43850f0f898b793d42aea7#l1310)) to convert the pointer to point to the chunk header. Then, if the chunk is allocated by `mmap` indicated by the M flag, `free` calls `munmap` ([man 3p](https://man.archlinux.org/man/munmap.3p.en) | [man 2](https://man.archlinux.org/man/munmap.2.en)) to release the chunk; if not, it passes the chunk pointer to `_int_free` ([source](https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=e065785af77af72c17c773517c15b248b067b4ad;hb=ae37d06c7d127817ba43850f0f898b793d42aea7#l4302)) for the actual freeing process.\\n\\nHowever, `free`-ing a memory chunk \\"does not actually return it to the operating system for other applications to use. The `free()` call marks a chunk of memory as \'free to be reused\' by the application, but from the operating system\'s point of view, the memory still \'belongs\' to the application\\" ([source](https://sourceware.org/glibc/wiki/MallocInternals#Free_Algorithm)) heap, meaning that the heap manager is still responsible of keeping track of the memory and reusing them when necessary.\\n\\nThat is why we use a circular linked list, with each chunk storing pointers to the previous and after, to organize the `free`-d chunks. Moreover, the size of the chunk is stored at the end of its memory area, _i.e._ the `chunk` pointer of the next chunk. Hence, the next chunk can use the size to access this `free`-d chunk and its header. When the next chunk is also `free`-d, we can use this property to [coalesce](https://cs.stackexchange.com/a/18234) the two chunks.\\n\\nOf course, the actual `free`-ing is much more complicated and the chunks will be put into different bins for efficient reallocation. You can read the official [glibc wiki](https://sourceware.org/glibc/wiki/MallocInternals), this more detailed [blog post](https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/), or the [source code for `_int_free`](https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=e065785af77af72c17c773517c15b248b067b4ad;hb=ae37d06c7d127817ba43850f0f898b793d42aea7#l4302) for more information.\\n\\n## How can we prevent memory leaks? {#how-can-we-prevent-memory-leaks}\\n\\nIt\'s probably time to come back to where we started: now that we\'ve known what memory leaks are, and how they happened, how do we effectively prevent them?\\n\\n1. Always `delete` (`delete[]`) objects created with `new` (`new[]`).\\n   - The simplest thing to do, if you insist using `new`.\\n2. Avoid calling `new` and `delete` explicitly\\n   - [Explanation](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#r11-avoid-calling-new-and-delete-explicitly)\\n   - **TL;DR**: Use a resource handle instead of naked pointers, which can be leaked.\\n   - Solution: use a smart pointer like `unique_ptr` or `shared_ptr`.\\n3. Never transfer ownership by a raw pointer (`T*`) or reference (`T&`)\\n   - [Explanation](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#i11-never-transfer-ownership-by-a-raw-pointer-t-or-reference-t)\\n   - **TL;DR**: it is unclear who should delete the pointer\\n   - Instead: return the object itself, or use a smart pointer\\n\\nIn general, requiring the programmer to manually free the resources is error-prone. You should consider [managing resources automatically using resource handles and RAII](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-raii) (Resource Acquisition is Initialization).\\n\\n## References & Further Readings {#references--further-readings}\\n\\n- Stroustrup, Bjarne and Sutter, Herb. [\\"C++ Core Guidelines\\"](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines). Updated Jun 17, 2021. Accessed Aug 08, 2021.\\n- glibc wiki. [\\"MallocInternals\\"](https://sourceware.org/glibc/wiki/MallocInternals). Updated May 20, 2019. Accessed Aug 08, 2021.\\n- Azeria Labs. [\\"Heap Exploitation Part 2: Understanding the Glibc Heap Implementation\\"](https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/). Accessed Aug 08, 2021.\\n- CTF Wiki. [\\"\u5806\u76f8\u5173\u6570\u636e\u7ed3\u6784\\"](https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/heap-structure/) (in Chinese). Accessed Aug 10, 2021.\\n- glibc Contributors. [glibc v2.34 source code](https://sourceware.org/git/?p=glibc.git;a=tree;h=6eb9f63e6c9197e967a8cc12a8b235335e5a873d;hb=ae37d06c7d127817ba43850f0f898b793d42aea7). Aug 2, 2021. Accessed Aug 8, 2021.\\n- gcc Contributors. [gcc v11.2.0 source code](https://github.com/gcc-mirror/gcc/tree/releases/gcc-11.2.0). Jul 28, 2021. Accessed Aug 8, 2021.\\n- StackOverflow. [\\"How does delete[] know the size of the operand array?\\"](https://stackoverflow.com/questions/197675/how-does-delete-know-the-size-of-the-operand-array)\\n\\nBTW, while Googling memory leaks, I found a wiki page [\\"Dealing With Memory Leaks\\"](https://wiki.bnl.gov/dayabay/index.php?title=Dealing_With_Memory_Leaks) from Daya Bay Reactor Neutrino Experiment project hosted under Brookhaven National Lab\'s domain. I didn\'t know that Daya Bay Reactor also hosted a multinational research project \ud83d\ude02."},{"id":"welcome","metadata":{"permalink":"/blog/welcome","editUrl":"https://github.com/yechs/website/edit/master/blog/blog/2021-04-22-welcome.md","source":"@site/blog/2021-04-22-welcome.md","title":"Me and My Broken Site(s)","description":"My personal website is finally up and running today! It is already 821 days after I purchased this domain (huh I\'m such big a procrastinator). I also have a blog running on the subdomain blog.shuye.dev for some longer and possibly non tech-related blog posts.","date":"2021-04-22T00:00:00.000Z","formattedDate":"April 22, 2021","tags":[{"label":"events","permalink":"/blog/tags/events"},{"label":"essays","permalink":"/blog/tags/essays"}],"readingTime":1.855,"truncated":true,"authors":[{"name":"Ye Shu","title":"Celebrating the launching of my new website","url":"https://github.com/yechs","imageURL":"https://avatars.githubusercontent.com/u/49149993"}],"prevItem":{"title":"Memory Leak & malloc chunks","permalink":"/blog/malloc_chunk"}},"content":"My personal website is finally up and running today! It is already 821 days after I purchased this domain (huh I\'m such big a procrastinator). I also have a blog running on the subdomain [blog.shuye.dev](https://blog.shuye.dev/) for some longer and possibly non tech-related blog posts.\\n\\nThis is not the first personal website I\'ve ever made. I coded my very first personal website in 2014 using static HTML and CSS (that was the time when most websites were still using HTML 4.01 and you had to decide whether you want a \\"strict\\" version of HTML), after a bit of self-learning with W3Schools. In fact, I wasn\'t even learning from the true [W3Schools](https://w3schools.com), but [an imitation of it](https://web.archive.org/web/20140103013237/http://w3school.com.cn/).\\n\\n\x3c!--truncate--\x3e\\n\\nThat was my first step, before I got into building more complicated (and dynamic!) websites using PHP, with the help from lecture videos of [Harvard\'s open course CS75](http://cs75.tv/2012/summer/). Shortly afterwards, I hosted my first dynamic website on the free hosting space RedHat OpenShift by 2016 (though it served more as a proxy server for me to get around the Internet censorship\u2014that would be the topic of some other day). Sadly, all these codes were lost during the years (I didn\'t even know how to use git at that time).\\n\\nSince then, I have hosted different sorts of personal websites: portfolios, WordPress blogs, and many lightweight alternatives like typecho or hugo. But to be honest I was more interested in the process of trying out new frameworks or toolsets, instead of actually settling down and writing something. And what use are websites of if not for sharing information?\\n\\nIn fact, that\'s what motivates me to still build blogs and websites to this day, in the year of 2021, when most people are turning to centralized social media platforms like WeChat, Instagram, Twitter ..., when small websites are almost extinct from public sight. I became so fed up by the frequent warnings of \\"sensitive words\\" that force me to water down and censor my comments so I finally decided to start (again) a website of my own to at least have a place to myself where I can actually write something undisturbed. And that\'s why, out of the innumerable possibilities, you are reading this article right now."}]}')}}]);