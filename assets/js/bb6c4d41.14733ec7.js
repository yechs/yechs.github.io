"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[96],{8225:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>u,frontMatter:()=>i,metadata:()=>l,toc:()=>d});var s=t(5893),o=t(1151),r=t(9286);const i={slug:"malloc_chunk",title:"Memory Leak & malloc chunks",author:"Ye Shu",author_title:"Studying how C++ allocates and frees chunks in memory",author_url:"https://github.com/yechs",author_image_url:"https://avatars.githubusercontent.com/u/49149993",image:"https://shuye.dev/img/yechs.jpeg",tags:["c++","pwn"]},a="Memory Leak & malloc chunks",l={permalink:"/blog/malloc_chunk",editUrl:"https://github.com/yechs/website/edit/master/blog/blog/2021-08-13-malloc_chunks.mdx",source:"@site/blog/2021-08-13-malloc_chunks.mdx",title:"Memory Leak & malloc chunks",description:"How it all started",date:"2021-08-13T00:00:00.000Z",formattedDate:"August 13, 2021",tags:[{label:"c++",permalink:"/blog/tags/c"},{label:"pwn",permalink:"/blog/tags/pwn"}],readingTime:16.47,hasTruncateMarker:!0,authors:[{name:"Ye Shu",title:"Studying how C++ allocates and frees chunks in memory",url:"https://github.com/yechs",imageURL:"https://avatars.githubusercontent.com/u/49149993"}],frontMatter:{slug:"malloc_chunk",title:"Memory Leak & malloc chunks",author:"Ye Shu",author_title:"Studying how C++ allocates and frees chunks in memory",author_url:"https://github.com/yechs",author_image_url:"https://avatars.githubusercontent.com/u/49149993",image:"https://shuye.dev/img/yechs.jpeg",tags:["c++","pwn"]},unlisted:!1,nextItem:{title:"Me and My Broken Site(s)",permalink:"/blog/welcome"}},c={authorsImageUrls:[void 0]},d=[{value:"How it all started",id:"how-it-all-started",level:2},{value:"What are Memory Leaks?",id:"what-are-memory-leaks",level:2},{value:"PoC",id:"poc",level:3},{value:"A Deeper Look into the Memory",id:"a-deeper-look-into-the-memory",level:3},{value:"Verification with Valgrind",id:"verification-with-valgrind",level:3},{value:"How are objects allocated on the heap?",id:"how-are-objects-allocated-on-the-heap",level:2},{value:"How <code>new</code> and <code>delete</code> works",id:"how-new-and-delete-works",level:3},{value:"<code>new[]</code> and <code>delete[]</code> are just wrappers of <code>new</code> and <code>delete</code>",id:"new-and-delete-are-just-wrappers-of-new-and-delete",level:4},{value:"And <code>new</code> &amp; <code>delete</code> are wrappers of <code>malloc</code> and <code>free</code>",id:"and-new--delete-are-wrappers-of-malloc-and-free",level:4},{value:"How are <code>malloc_chunk</code>s structured?",id:"how-are-malloc_chunks-structured",level:3},{value:"A verification using PoC",id:"a-verification-using-poc",level:3},{value:"How does <code>free</code> work?",id:"how-does-free-work",level:3},{value:"How can we prevent memory leaks?",id:"how-can-we-prevent-memory-leaks",level:2},{value:"References &amp; Further Readings",id:"references--further-readings",level:2}];function h(e){const n={a:"a",admonition:"admonition",annotation:"annotation",blockquote:"blockquote",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",li:"li",math:"math",mn:"mn",mo:"mo",mrow:"mrow",ol:"ol",p:"p",pre:"pre",semantics:"semantics",span:"span",strong:"strong",ul:"ul",...(0,o.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"how-it-all-started",children:"How it all started"}),"\n",(0,s.jsxs)(n.p,{children:["While debugging a memory leak bug during my summer internship, I found out that one of our APIs returned a raw pointer and thus transferred its ownership to the caller (me). In other words, I'm now responsible of ",(0,s.jsx)(n.code,{children:"delete"}),"-ing the pointer after my code finishes. While this is ",(0,s.jsx)(n.a,{href:"https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#i11-never-transfer-ownership-by-a-raw-pointer-t-or-reference-t",children:"a terrible engineering practice"}),", I grew interested in how memory leaks happen, and how ",(0,s.jsx)(n.code,{children:"delete[]"})," solves the problem."]}),"\n",(0,s.jsx)(n.p,{children:"After some research & experiments, I wrote this blog post, which hopefully addresses three sets of questions"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"What are memory leaks?"}),"\n",(0,s.jsxs)(n.li,{children:["How are objects allocated on the heap? How does ",(0,s.jsx)(n.code,{children:"delete[]"})," know which area of memory to be freed?"]}),"\n",(0,s.jsx)(n.li,{children:"How can we prevent memory leaks from happening?"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["While the Stack Overflow question ",(0,s.jsx)(n.a,{href:"https://stackoverflow.com/questions/197675/how-does-delete-know-the-size-of-the-operand-array",children:"\"How does delete[] 'know' the size of the operand array?\""})," sort of answers the second question, I decide to dig deeper into the actual memory area."]}),"\n",(0,s.jsxs)(n.p,{children:["Coincidentally, I have worked on a heap exploitation problem with my friend ",(0,s.jsx)(n.a,{href:"https://guozhen.dev",children:"@gzhding"})," in a past CTF event. Thanks to the experience, I learned how to use ",(0,s.jsx)(n.code,{children:"gdb"})," to dump the heap memory and gain some insight into the problem."]}),"\n","\n","\n",(0,s.jsx)(r.Z,{toc:d}),"\n",(0,s.jsx)(n.h2,{id:"what-are-memory-leaks",children:"What are Memory Leaks?"}),"\n",(0,s.jsxs)(n.p,{children:["We know that ",(0,s.jsx)(n.a,{href:"https://www.cplusplus.com/doc/tutorial/dynamic/",children:"C++ can dynamically allocate memory on the heap"}),". A common example is to use ",(0,s.jsx)(n.code,{children:"new[]"})," to create an array and ",(0,s.jsx)(n.code,{children:"delete[]"})," to remove it."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Memory_leak",children:"Memory leaks"})," happens when we create an array in the memory (",(0,s.jsx)(n.em,{children:"i.e."}),' "allocates" a segment of memory to store the object) and forget to delete it. When the pointer to the memory goes out of scope, the running code becomes ignorant of the allocated memory area. In worst cases, when the leakage happens in a loop, newly allocated memory will continue to pile up without being released, potentially slowing down or crash the computer.']}),"\n",(0,s.jsx)(n.h3,{id:"poc",children:"PoC"}),"\n",(0,s.jsxs)(n.p,{children:["Here is a short Proof of Concept (PoC) code. The ",(0,s.jsx)(n.code,{children:"main()"})," function calls the ",(0,s.jsx)(n.code,{children:"memory_leak()"})," function, which allocates an array of 26 ",(0,s.jsx)(n.code,{children:"char"}),"s and fills them with capital English alphabets."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",metastring:'title="memory_leak.cpp"',children:"void memory_leak() {\n    // Always delete pointers created by new to avoid memory leaks!\n    char *arr = new char[26];\n\n    for (int i = 0; i < 26; i++) {\n        arr[i] = char(65 + i); // 65 is the ascii of 'A'\n    }\n\n    // The memory area is not freed!\n    // delete[] arr;\n}\n\nint main() {\n    memory_leak();\n    return 0;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["As the ",(0,s.jsx)(n.code,{children:"delete[]"})," statement is commented out, when the function ",(0,s.jsx)(n.code,{children:"memory_leak()"})," returns, the pointer ",(0,s.jsx)(n.code,{children:"arr"})," goes out of scope and results in the memory area leaked."]}),"\n",(0,s.jsx)(n.h3,{id:"a-deeper-look-into-the-memory",children:"A Deeper Look into the Memory"}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsxs)(n.p,{children:["Instead of native GDB, I use ",(0,s.jsx)(n.a,{href:"https://github.com/hugsy/gef",children:"GEF"})," (GDB Enhanced Features) for prettified output and some extra features like ",(0,s.jsx)(n.code,{children:"heap"}),"."]})}),"\n",(0,s.jsxs)(n.p,{children:["Let us compile the program with ",(0,s.jsx)(n.code,{children:"g++ -g3 memory_leak.cpp -o memory_leak"})," (the ",(0,s.jsx)(n.code,{children:"-g3"})," flag preserves debug information during compilation) and use ",(0,s.jsx)(n.code,{children:"gdb"})," to verify the memory leak."]}),"\n",(0,s.jsxs)(n.p,{children:["We'll add a breakpoint at the end of function ",(0,s.jsx)(n.code,{children:"memory_leak()"})," and run the program until it hits the breakpoint."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-console",children:'$ gdb memory_leak\n\ngef\u27a4  b 11\nBreakpoint 1 at 0x1179: file memory_leak.cpp, line 11.\n\ngef\u27a4  r\n[...]\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 source:memory_leak.cpp+11 \u2500\u2500\u2500\u2500\n      6          arr[i] = char(65 + i); // 65 is the ascii of \'A\'\n      7      }\n      8\n      9      // The memory area is not freed!\n     10      // delete[] arr;\n\u25cf\u2192   11  }\n     12\n     13  int main() {\n     14      memory_leak();\n     15      return 0;\n     16  }\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 threads \u2500\u2500\u2500\u2500\n[#0] Id 1, Name: "memory_leak", stopped 0x555555555179 in memory_leak (), reason: BREAKPOINT\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 trace \u2500\u2500\u2500\u2500\n[#0] 0x555555555179 \u2192 memory_leak()\n[#1] 0x555555555186 \u2192 main()\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\ngef\u27a4  info locals\narr = 0x55555556aeb0 "ABCDEFGHIJKLMNOPQRSTUVWXYZ"\n\ngef\u27a4  x/8xw 0x55555556aeb0\n0x55555556aeb0: 0x44434241      0x48474645      0x4c4b4a49      0x504f4e4d\n0x55555556aec0: 0x54535251      0x58575655      0x00005a59      0x00000000\n'})}),"\n",(0,s.jsxs)(n.p,{children:["After the program hits the breakpoint, we print out the address of pointer ",(0,s.jsx)(n.code,{children:"arr"})," and the content of that memory. Note that the memory is stored in ",(0,s.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Little-endian",children:"little endian"})," order, so ",(0,s.jsx)(n.code,{children:"0x44"})," (D) comes before ",(0,s.jsx)(n.code,{children:"0x43"})," (C), ",(0,s.jsx)(n.code,{children:"0x42"})," (B), and finally ",(0,s.jsx)(n.code,{children:"0x41"})," (A)."]}),"\n",(0,s.jsxs)(n.p,{children:["Now, let us continue running the program until ",(0,s.jsx)(n.code,{children:"memory_leak()"})," returns back to ",(0,s.jsx)(n.code,{children:"main()"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-gdb",children:'gef\u27a4  finish\n[...]\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 source:memory_leak.cpp+15 \u2500\u2500\u2500\u2500\n     10      // delete[] arr;\n\u25cf    11  }\n     12\n     13  int main() {\n     14      memory_leak();\n \u2192   15      return 0;\n     16  }\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 threads \u2500\u2500\u2500\u2500\n[#0] Id 1, Name: "memory_leak", stopped 0x555555555186 in main (), reason: TEMPORARY BREAKPOINT\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 trace \u2500\u2500\u2500\u2500\n[#0] 0x555555555186 \u2192 main()\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\ngef\u27a4  info locals\nNo locals.\n\ngef\u27a4  x/8xw 0x55555556aeb0\n0x55555556aeb0: 0x44434241      0x48474645      0x4c4b4a49      0x504f4e4d\n0x55555556aec0: 0x54535251      0x58575655      0x00005a59      0x00000000\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Now that ",(0,s.jsx)(n.code,{children:"memory_leak()"})," returns, we have lost the pointer ",(0,s.jsx)(n.code,{children:"arr"})," pointing to the memory address ",(0,s.jsx)(n.code,{children:"0x55555556aeb0"}),". However, as we print out the memory area, the data is still stored in the memory without being released, leading to a memory leak."]}),"\n",(0,s.jsx)(n.h3,{id:"verification-with-valgrind",children:"Verification with Valgrind"}),"\n",(0,s.jsxs)(n.p,{children:["Furthermore, we can use automated tools like ",(0,s.jsx)(n.a,{href:"https://valgrind.org",children:"Valgrind"})," to check for memory leaks."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-console",children:"$ valgrind --leak-check=full ./memory_leak\n==382643== Memcheck, a memory error detector\n==382643== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.\n==382643== Using Valgrind-3.17.0 and LibVEX; rerun with -h for copyright info\n==382643== Command: ./memory_leak\n==382643==\n==382643==\n==382643== HEAP SUMMARY:\n==382643==     in use at exit: 26 bytes in 1 blocks\n==382643==   total heap usage: 2 allocs, 1 frees, 72,730 bytes allocated\n==382643==\n==382643== 26 bytes in 1 blocks are definitely lost in loss record 1 of 1\n==382643==    at 0x484021F: operator new[](unsigned long) (vg_replace_malloc.c:579)\n==382643==    by 0x10914A: memory_leak() (memory_leak.cpp:3)\n==382643==    by 0x109185: main (memory_leak.cpp:14)\n==382643==\n==382643== LEAK SUMMARY:\n==382643==    definitely lost: 26 bytes in 1 blocks\n==382643==    indirectly lost: 0 bytes in 0 blocks\n==382643==      possibly lost: 0 bytes in 0 blocks\n==382643==    still reachable: 0 bytes in 0 blocks\n==382643==         suppressed: 0 bytes in 0 blocks\n==382643==\n==382643== For lists of detected and suppressed errors, rerun with: -s\n==382643== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)\n"})}),"\n",(0,s.jsx)(n.h2,{id:"how-are-objects-allocated-on-the-heap",children:"How are objects allocated on the heap?"}),"\n",(0,s.jsxs)(n.p,{children:["To understand better the mechanisms behind memory leaks, we need to know how C++ allocates and frees memories, ",(0,s.jsx)(n.em,{children:"i.e."})," how ",(0,s.jsx)(n.code,{children:"new"})," and ",(0,s.jsx)(n.code,{children:"delete"})," works. Let us dig deeper into the source code of GNU's ",(0,s.jsx)(n.code,{children:"libstdc++"})," implementation (the library used by g++ by default)."]}),"\n",(0,s.jsxs)(n.h3,{id:"how-new-and-delete-works",children:["How ",(0,s.jsx)(n.code,{children:"new"})," and ",(0,s.jsx)(n.code,{children:"delete"})," works"]}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsxs)(n.p,{children:["As ",(0,s.jsx)(n.code,{children:"new"})," and ",(0,s.jsx)(n.code,{children:"delete"})," operators are merely interfaces defined by the C++ standard and have different implementations, here I'll use the ",(0,s.jsx)(n.a,{href:"https://github.com/gcc-mirror/gcc/tree/releases/gcc-11.2.0",children:"source code"})," of GNU's ",(0,s.jsx)(n.code,{children:"libstdc++"})," that ships with gcc version 11.2.0 for reference."]})}),"\n",(0,s.jsxs)(n.h4,{id:"new-and-delete-are-just-wrappers-of-new-and-delete",children:[(0,s.jsx)(n.code,{children:"new[]"})," and ",(0,s.jsx)(n.code,{children:"delete[]"})," are just wrappers of ",(0,s.jsx)(n.code,{children:"new"})," and ",(0,s.jsx)(n.code,{children:"delete"})]}),"\n",(0,s.jsxs)(n.p,{children:["Interestingly, from the implementation of ",(0,s.jsx)(n.code,{children:"operator new[]"})," (",(0,s.jsx)(n.a,{href:"https://github.com/gcc-mirror/gcc/blob/releases/gcc-11.2.0/libstdc++-v3/libsupc++/new_opv.cc#L29-L33",children:"source"}),"), it seems that in ",(0,s.jsx)(n.code,{children:"stdlibc++"}),", ",(0,s.jsx)(n.code,{children:"new[]"})," is just an alias for ",(0,s.jsx)(n.code,{children:"new"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",metastring:'title="/libstdc++-v3/libsupc++/new_opv.cc:L29-33"',children:"_GLIBCXX_WEAK_DEFINITION void*\noperator new[] (std::size_t sz) _GLIBCXX_THROW (std::bad_alloc)\n{\n  return ::operator new(sz);\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The same is true for ",(0,s.jsx)(n.code,{children:"delete[]"})," (",(0,s.jsx)(n.a,{href:"https://github.com/gcc-mirror/gcc/blob/releases/gcc-11.2.0/libstdc++-v3/libsupc++/del_opv.cc#L32-L36",children:"source"}),"), which is just an alias for ",(0,s.jsx)(n.code,{children:"delete"}),"."]}),"\n",(0,s.jsxs)(n.admonition,{type:"caution",children:[(0,s.jsxs)(n.p,{children:["From the implementation of GNU stdlibc++, it seems perfectly ok to mix the use of ",(0,s.jsx)(n.code,{children:"new[]"})," with ",(0,s.jsx)(n.code,{children:"new"}),", and ",(0,s.jsx)(n.code,{children:"delete[]"})," with ",(0,s.jsx)(n.code,{children:"delete"}),"."]}),(0,s.jsxs)(n.p,{children:["However, you should never do this, because this behavior is implementation-specific. Using ",(0,s.jsx)(n.code,{children:"new"})," and ",(0,s.jsx)(n.code,{children:"delete"})," instead of ",(0,s.jsx)(n.code,{children:"new[]"})," and ",(0,s.jsx)(n.code,{children:"delete[]"})," leads to undefined behavior (according to ",(0,s.jsx)(n.a,{href:"https://timsong-cpp.github.io/cppwp/expr.delete#2",children:"C++ Working Paper"}),") and will make your life painful."]})]}),"\n",(0,s.jsxs)(n.h4,{id:"and-new--delete-are-wrappers-of-malloc-and-free",children:["And ",(0,s.jsx)(n.code,{children:"new"})," & ",(0,s.jsx)(n.code,{children:"delete"})," are wrappers of ",(0,s.jsx)(n.code,{children:"malloc"})," and ",(0,s.jsx)(n.code,{children:"free"})]}),"\n",(0,s.jsxs)(n.p,{children:["Now let us take a look at the ",(0,s.jsx)(n.a,{href:"https://github.com/gcc-mirror/gcc/blob/releases/gcc-11.2.0/libstdc++-v3/libsupc++/new_op.cc#L41-L59",children:"source code"})," of ",(0,s.jsx)(n.code,{children:"new"}),". It's just a wrapper around C's ",(0,s.jsx)(n.code,{children:"malloc"})," plus some error handling and returns the ",(0,s.jsx)(n.code,{children:"malloc"}),"-ed raw pointer to the caller."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",metastring:'title="/libstdc++-v3/libsupc++/new_op.cc:L41-59"',children:"_GLIBCXX_WEAK_DEFINITION void *\noperator new (std::size_t sz) _GLIBCXX_THROW (std::bad_alloc)\n{\n  void *p;\n\n  /* malloc (0) is unpredictable; avoid it.  */\n  if (__builtin_expect (sz == 0, false))\n    sz = 1;\n\n  while ((p = malloc (sz)) == 0)\n    {\n      new_handler handler = std::get_new_handler ();\n      if (! handler)\n\t_GLIBCXX_THROW_OR_ABORT(bad_alloc());\n      handler ();\n    }\n\n  return p;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"delete"})," (",(0,s.jsx)(n.a,{href:"https://github.com/gcc-mirror/gcc/blob/releases/gcc-11.2.0/libstdc++-v3/libsupc++/del_op.cc#L46-L50",children:"source"}),") is even simpler, and just calls C's ",(0,s.jsx)(n.code,{children:"free"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",metastring:'title="libstdc++-v3/libsupc++/del_op.cc:L46-50"',children:"_GLIBCXX_WEAK_DEFINITION void\noperator delete(void* ptr) noexcept\n{\n  std::free(ptr);\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Hence it seems that we should dive all the way into C standard library's implementation of ",(0,s.jsx)(n.code,{children:"malloc"})," and ",(0,s.jsx)(n.code,{children:"free"})," and see what exactly is happening behind the creation and deletion of arrays."]}),"\n",(0,s.jsxs)(n.p,{children:["However, instead of covering the full picture of ",(0,s.jsx)(n.code,{children:"malloc"})," (which could fill another blog post), we'll be mainly focusing on how ",(0,s.jsx)(n.code,{children:"malloc"})," structures the allocated memory area (answer: using ",(0,s.jsx)(n.code,{children:"malloc_chunk"}),"s on the heap) and how ",(0,s.jsx)(n.code,{children:"free"})," knows which area of memory to be released."]}),"\n",(0,s.jsxs)(n.h3,{id:"how-are-malloc_chunks-structured",children:["How are ",(0,s.jsx)(n.code,{children:"malloc_chunk"}),"s structured?"]}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsxs)(n.p,{children:["Like in the previous section, I will use GNU's implementation of C standard library, ",(0,s.jsx)(n.em,{children:"i.e."})," ",(0,s.jsx)(n.code,{children:"glibc"}),".\nThe current version is ",(0,s.jsx)(n.a,{href:"https://sourceware.org/git/?p=glibc.git;a=tag;h=refs/tags/glibc-2.34",children:"glibc 2.34"}),", which is released on Aug 2, 2021."]})}),"\n",(0,s.jsxs)(n.p,{children:["The following content comes from the comments in ",(0,s.jsx)(n.code,{children:"malloc/malloc.c"})," of glibc (",(0,s.jsx)(n.a,{href:"https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=e065785af77af72c17c773517c15b248b067b4ad;hb=ae37d06c7d127817ba43850f0f898b793d42aea7#l1168",children:"source"}),"). I've done some minor edits to adapt the format to Markdown (what this website uses)."]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"(The following includes lightly edited explanations by Colin Plumb.)"}),"\n",(0,s.jsxs)(n.p,{children:["Chunks of memory are maintained using a `boundary tag' method as\ndescribed in e.g., Knuth or Standish. (See the paper by Paul\nWilson ",(0,s.jsx)(n.a,{href:"ftp://ftp.cs.utexas.edu/pub/garbage/allocsrv.ps",children:"ftp://ftp.cs.utexas.edu/pub/garbage/allocsrv.ps"})," for a\nsurvey of such techniques.) Sizes of free chunks are stored both\nin the front of each chunk and at the end. This makes\nconsolidating fragmented chunks into bigger chunks very fast. The\nsize fields also hold bits representing whether chunks are free or\nin use."]}),"\n",(0,s.jsx)(n.p,{children:"An allocated chunk looks like this:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"    chunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n            |             Size of previous chunk, if unallocated (P clear)  |\n            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n            |             Size of chunk, in bytes                     |A|M|P|\n      mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n            |             User data starts here...                          .\n            .                                                               .\n            .             (malloc_usable_size() bytes)                      .\n            .                                                               |\nnextchunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n            |             (size of chunk, but used for application data)    |\n            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n            |             Size of next chunk, in bytes                |A|0|1|\n            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"})}),"\n",(0,s.jsx)(n.p,{children:'Where "chunk" is the front of the chunk for the purpose of most of\nthe malloc code, but "mem" is the pointer that is returned to the\nuser. "Nextchunk" is the beginning of the next contiguous chunk.'}),"\n",(0,s.jsx)(n.p,{children:"Chunks always begin on even word boundaries, so the mem portion\n(which is returned to the user) is also on an even word boundary, and\nthus at least double-word aligned."}),"\n",(0,s.jsx)(n.p,{children:"Free chunks are stored in circular doubly-linked lists, and look like this:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"    chunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n            |             Size of previous chunk, if unallocated (P clear)  |\n            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    `head:' |             Size of chunk, in bytes                     |A|0|P|\n      mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n            |             Forward pointer to next chunk in list             |\n            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n            |             Back pointer to previous chunk in list            |\n            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n            |             Unused space (may be 0 bytes long)                .\n            .                                                               .\n            .                                                               |\nnextchunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    `foot:' |             Size of chunk, in bytes                           |\n            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n            |             Size of next chunk, in bytes                |A|0|0|\n            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The P (",(0,s.jsx)(n.code,{children:"PREV_INUSE"}),") bit, stored in the unused low-order bit of the\nchunk size (which is always a multiple of two words), is an in-use\nbit for the ",(0,s.jsx)(n.em,{children:"previous"})," chunk. If that bit is ",(0,s.jsx)(n.em,{children:"clear"}),", then the\nword before the current chunk size contains the previous chunk\nsize, and can be used to find the front of the previous chunk.\nThe very first chunk allocated always has this bit set,\npreventing access to non-existent (or non-owned) memory. If\n",(0,s.jsx)(n.code,{children:"prev_inuse"})," is set for any given chunk, then you CANNOT determine\nthe size of the previous chunk, and might even get a memory\naddressing fault when trying to do so."]}),"\n",(0,s.jsx)(n.p,{children:"[...]"}),"\n",(0,s.jsxs)(n.p,{children:["Note that the ",(0,s.jsx)(n.code,{children:"foot"})," of the current chunk is actually represented\nas the ",(0,s.jsx)(n.code,{children:"prev_size"})," of the NEXT chunk. This makes it easier to\ndeal with alignments etc but can be very confusing when trying\nto extend or adapt this code."]}),"\n",(0,s.jsx)(n.p,{children:"[...]"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"a-verification-using-poc",children:"A verification using PoC"}),"\n",(0,s.jsxs)(n.p,{children:["Now we can use ",(0,s.jsx)(n.code,{children:"gdb"})," to actually print out the memory area and see how the explanation above applies to our case. Here I used the ",(0,s.jsx)(n.code,{children:"heap"})," feature introduced by ",(0,s.jsx)(n.a,{href:"https://gef.readthedocs.io/en/master/commands/heap/#heap-chunk-command",children:"GEF"})," to better visualize the ",(0,s.jsx)(n.code,{children:"malloc"}),"-ed chunk's properties."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"gef\u27a4  heap chunk arr\nChunk(addr=0x55555556aeb0, size=0x30, flags=PREV_INUSE)\nChunk size: 48 (0x30)\nUsable size: 40 (0x28)\nPrevious chunk size: 0 (0x0)\nPREV_INUSE flag: On\nIS_MMAPPED flag: Off\nNON_MAIN_ARENA flag: Off\n\ngef\u27a4  x/16xw 0x55555556aeb0-16\n0x55555556aea0:\t0x00000000\t0x00000000\t0x00000031\t0x00000000\n0x55555556aeb0:\t0x44434241\t0x48474645\t0x4c4b4a49\t0x504f4e4d\n0x55555556aec0:\t0x54535251\t0x58575655\t0x00005a59\t0x00000000\n0x55555556aed0:\t0x00000000\t0x00000000\t0x0000f131\t0x00000000\n"})}),"\n",(0,s.jsx)(n.p,{children:'Note that here the chunk size is 48 bytes, with the usable size (size of actual user memory area) being 40, which is much higher than what we requested (an array of 26 chars, which should be 26 bytes). This is because "chunks always begin on even word boundaries ... and thus at least double-word aligned." (from the blockquote above).'}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsxs)(n.p,{children:["The size of a ",(0,s.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Word_(computer_architecture)",children:"word"})," varies by architecture. For a normal 64 bit system, the word is 64 bit long and thus takes up 8 bytes in size. However, a word in ",(0,s.jsx)(n.code,{children:"gdb"})," ",(0,s.jsx)(n.code,{children:"x/w"}),' command has a fixed length of 32 bits (4 bytes), which is a bit confusing. Hence, I\'ll use "word" to refer to an actual variable-size word, and "32-bit word" to refer to the ',(0,s.jsx)(n.code,{children:"gdb"})," word."]})}),"\n",(0,s.jsxs)(n.p,{children:["Since the chunk in memory is always double-word aligned, we should minus the address by ",(0,s.jsxs)(n.span,{className:"katex",children:[(0,s.jsx)(n.span,{className:"katex-mathml",children:(0,s.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,s.jsxs)(n.semantics,{children:[(0,s.jsxs)(n.mrow,{children:[(0,s.jsx)(n.mn,{children:"2"}),(0,s.jsx)(n.mo,{children:"\xd7"}),(0,s.jsx)(n.mn,{children:"8"}),(0,s.jsx)(n.mo,{children:"="}),(0,s.jsx)(n.mn,{children:"16"})]}),(0,s.jsx)(n.annotation,{encoding:"application/x-tex",children:"2\\times8=16"})]})})}),(0,s.jsxs)(n.span,{className:"katex-html","aria-hidden":"true",children:[(0,s.jsxs)(n.span,{className:"base",children:[(0,s.jsx)(n.span,{className:"strut",style:{height:"0.7278em",verticalAlign:"-0.0833em"}}),(0,s.jsx)(n.span,{className:"mord",children:"2"}),(0,s.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,s.jsx)(n.span,{className:"mbin",children:"\xd7"}),(0,s.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,s.jsxs)(n.span,{className:"base",children:[(0,s.jsx)(n.span,{className:"strut",style:{height:"0.6444em"}}),(0,s.jsx)(n.span,{className:"mord",children:"8"}),(0,s.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2778em"}}),(0,s.jsx)(n.span,{className:"mrel",children:"="}),(0,s.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2778em"}})]}),(0,s.jsxs)(n.span,{className:"base",children:[(0,s.jsx)(n.span,{className:"strut",style:{height:"0.6444em"}}),(0,s.jsx)(n.span,{className:"mord",children:"16"})]})]})]})," bytes to obtain the ",(0,s.jsx)(n.code,{children:"chunk"})," pointer address. Here the first word (represented by 2 32-bit words as in gdb) is filled with ",(0,s.jsx)(n.code,{children:"0x00"}),", and will be filled with the area of the previous chunk, if the ",(0,s.jsx)(n.code,{children:"P"})," flag in unset."]}),"\n",(0,s.jsxs)(n.p,{children:["The second word ",(0,s.jsx)(n.code,{children:"0x31"})," (or ",(0,s.jsx)(n.code,{children:"0b110001"}),") stores the chunk size and 3 flags. The least significant bit ",(0,s.jsx)(n.code,{children:"0b1"})," indicates that the flag ",(0,s.jsx)(n.code,{children:"P"})," (PREV_INUSE) is set, so the previous chunk has not been freed. Since all chunks must have size at least of multiples of 8, the 3 least significant bits of the size field is always 0, which is why the 3 LSBs can be used as flags. To calculate the chunk size, we can discard the 3 LSBs and obtain ",(0,s.jsx)(n.code,{children:"0b110000"})," (",(0,s.jsx)(n.code,{children:"0x30"}),", or 48) bytes."]}),"\n",(0,s.jsxs)(n.admonition,{type:"note",children:[(0,s.jsxs)(n.p,{children:["If you are cautious enough, you might have noticed that the usable size for the chunk is 40, which is only 8 bytes (not 16), ",(0,s.jsx)(n.em,{children:"i.e."})," one word, less than the chunk size."]}),(0,s.jsxs)(n.p,{children:["This is because the ",(0,s.jsx)(n.code,{children:"chunk"})," pointer ",(0,s.jsx)(n.a,{href:"https://sourceware.org/glibc/wiki/MallocInternals#What_is_a_Chunk.3F",children:'"does not point to the beginning of the chunk, but to the last word in the previous chunk"'}),". The actual chunk starts at the next word of ",(0,s.jsx)(n.code,{children:"chunk"})," pointer (which stores the sizes)."]})]}),"\n",(0,s.jsxs)(n.p,{children:['So, our "actual" chunk starts at the address ',(0,s.jsx)(n.code,{children:"0x55555556aea8"})," and ends at ",(0,s.jsx)(n.code,{children:"0x55555556aec8"}),". The data area starts from ",(0,s.jsx)(n.code,{children:"0x55555556aeb0"})," and ends in ",(0,s.jsx)(n.code,{children:"0x55555556aec8"}),". Similarly, the next ",(0,s.jsx)(n.code,{children:"chunk"})," pointer points to the last word in our chunk's data area (",(0,s.jsx)(n.code,{children:"0x55555556aec8"}),")."]}),"\n",(0,s.jsxs)(n.p,{children:["Then, why does the chunk pointer confusingly points to the last word in the previous chunk? The answer is related to the ",(0,s.jsx)(n.code,{children:"free"})," design mechanism."]}),"\n",(0,s.jsxs)(n.p,{children:["Because when the previous chunk is freed, it'll fill its last word with its size and clear the ",(0,s.jsx)(n.code,{children:"P"}),' flag in its next chunk (ours). Hence, our chunk can use this size "to find the front of the previous chunk" after the previous chunk has been freed.']}),"\n",(0,s.jsxs)(n.h3,{id:"how-does-free-work",children:["How does ",(0,s.jsx)(n.code,{children:"free"})," work?"]}),"\n",(0,s.jsxs)(n.p,{children:['By now, you should already have the answer to "how does ',(0,s.jsx)(n.code,{children:"delete[]"}),' know which area of memory to be freed"\u2014because the size of the chunk is stored in its metadata.']}),"\n",(0,s.jsxs)(n.p,{children:["However, there are still some intricacies to be solved: why does the chunk pointer points to the last word in the previous chunk? Why do we need the ",(0,s.jsx)(n.code,{children:"PREV_INUSE"})," (P) flag? To do so, we shall look into how ",(0,s.jsx)(n.code,{children:"free"})," works."]}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsxs)(n.p,{children:["While reading this section, you can refer back to the section ",(0,s.jsx)(n.a,{href:"#how-are-malloc_chunks-structured",children:"How are malloc_chunks structured?\n"})," to see how memory chunks look like before and after ",(0,s.jsx)(n.code,{children:"free"}),"."]})}),"\n",(0,s.jsxs)(n.p,{children:["Long story short, ",(0,s.jsx)(n.code,{children:"free"})," works like the following. When it is called (",(0,s.jsx)(n.a,{href:"https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=e065785af77af72c17c773517c15b248b067b4ad;hb=ae37d06c7d127817ba43850f0f898b793d42aea7#l3237",children:"source"}),"), the user would pass a pointer to the memory area to it, ",(0,s.jsx)(n.code,{children:"free"})," would then call ",(0,s.jsx)(n.code,{children:"mem2chunk"})," (",(0,s.jsx)(n.a,{href:"https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=e065785af77af72c17c773517c15b248b067b4ad;hb=ae37d06c7d127817ba43850f0f898b793d42aea7#l1310",children:"source"}),") to convert the pointer to point to the chunk header. Then, if the chunk is allocated by ",(0,s.jsx)(n.code,{children:"mmap"})," indicated by the M flag, ",(0,s.jsx)(n.code,{children:"free"})," calls ",(0,s.jsx)(n.code,{children:"munmap"})," (",(0,s.jsx)(n.a,{href:"https://man.archlinux.org/man/munmap.3p.en",children:"man 3p"})," | ",(0,s.jsx)(n.a,{href:"https://man.archlinux.org/man/munmap.2.en",children:"man 2"}),") to release the chunk; if not, it passes the chunk pointer to ",(0,s.jsx)(n.code,{children:"_int_free"})," (",(0,s.jsx)(n.a,{href:"https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=e065785af77af72c17c773517c15b248b067b4ad;hb=ae37d06c7d127817ba43850f0f898b793d42aea7#l4302",children:"source"}),") for the actual freeing process."]}),"\n",(0,s.jsxs)(n.p,{children:["However, ",(0,s.jsx)(n.code,{children:"free"}),'-ing a memory chunk "does not actually return it to the operating system for other applications to use. The ',(0,s.jsx)(n.code,{children:"free()"})," call marks a chunk of memory as 'free to be reused' by the application, but from the operating system's point of view, the memory still 'belongs' to the application\" (",(0,s.jsx)(n.a,{href:"https://sourceware.org/glibc/wiki/MallocInternals#Free_Algorithm",children:"source"}),") heap, meaning that the heap manager is still responsible of keeping track of the memory and reusing them when necessary."]}),"\n",(0,s.jsxs)(n.p,{children:["That is why we use a circular linked list, with each chunk storing pointers to the previous and after, to organize the ",(0,s.jsx)(n.code,{children:"free"}),"-d chunks. Moreover, the size of the chunk is stored at the end of its memory area, ",(0,s.jsx)(n.em,{children:"i.e."})," the ",(0,s.jsx)(n.code,{children:"chunk"})," pointer of the next chunk. Hence, the next chunk can use the size to access this ",(0,s.jsx)(n.code,{children:"free"}),"-d chunk and its header. When the next chunk is also ",(0,s.jsx)(n.code,{children:"free"}),"-d, we can use this property to ",(0,s.jsx)(n.a,{href:"https://cs.stackexchange.com/a/18234",children:"coalesce"})," the two chunks."]}),"\n",(0,s.jsxs)(n.p,{children:["Of course, the actual ",(0,s.jsx)(n.code,{children:"free"}),"-ing is much more complicated and the chunks will be put into different bins for efficient reallocation. You can read the official ",(0,s.jsx)(n.a,{href:"https://sourceware.org/glibc/wiki/MallocInternals",children:"glibc wiki"}),", this more detailed ",(0,s.jsx)(n.a,{href:"https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/",children:"blog post"}),", or the ",(0,s.jsxs)(n.a,{href:"https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=e065785af77af72c17c773517c15b248b067b4ad;hb=ae37d06c7d127817ba43850f0f898b793d42aea7#l4302",children:["source code for ",(0,s.jsx)(n.code,{children:"_int_free"})]})," for more information."]}),"\n",(0,s.jsx)(n.h2,{id:"how-can-we-prevent-memory-leaks",children:"How can we prevent memory leaks?"}),"\n",(0,s.jsx)(n.p,{children:"It's probably time to come back to where we started: now that we've known what memory leaks are, and how they happened, how do we effectively prevent them?"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["Always ",(0,s.jsx)(n.code,{children:"delete"})," (",(0,s.jsx)(n.code,{children:"delete[]"}),") objects created with ",(0,s.jsx)(n.code,{children:"new"})," (",(0,s.jsx)(n.code,{children:"new[]"}),").","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["The simplest thing to do, if you insist using ",(0,s.jsx)(n.code,{children:"new"}),"."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["Avoid calling ",(0,s.jsx)(n.code,{children:"new"})," and ",(0,s.jsx)(n.code,{children:"delete"})," explicitly","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#r11-avoid-calling-new-and-delete-explicitly",children:"Explanation"})}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"TL;DR"}),": Use a resource handle instead of naked pointers, which can be leaked."]}),"\n",(0,s.jsxs)(n.li,{children:["Solution: use a smart pointer like ",(0,s.jsx)(n.code,{children:"unique_ptr"})," or ",(0,s.jsx)(n.code,{children:"shared_ptr"}),"."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["Never transfer ownership by a raw pointer (",(0,s.jsx)(n.code,{children:"T*"}),") or reference (",(0,s.jsx)(n.code,{children:"T&"}),")","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#i11-never-transfer-ownership-by-a-raw-pointer-t-or-reference-t",children:"Explanation"})}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"TL;DR"}),": it is unclear who should delete the pointer"]}),"\n",(0,s.jsx)(n.li,{children:"Instead: return the object itself, or use a smart pointer"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["In general, requiring the programmer to manually free the resources is error-prone. You should consider ",(0,s.jsx)(n.a,{href:"https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-raii",children:"managing resources automatically using resource handles and RAII"})," (Resource Acquisition is Initialization)."]}),"\n",(0,s.jsx)(n.h2,{id:"references--further-readings",children:"References & Further Readings"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Stroustrup, Bjarne and Sutter, Herb. ",(0,s.jsx)(n.a,{href:"https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines",children:'"C++ Core Guidelines"'}),". Updated Jun 17, 2021. Accessed Aug 08, 2021."]}),"\n",(0,s.jsxs)(n.li,{children:["glibc wiki. ",(0,s.jsx)(n.a,{href:"https://sourceware.org/glibc/wiki/MallocInternals",children:'"MallocInternals"'}),". Updated May 20, 2019. Accessed Aug 08, 2021."]}),"\n",(0,s.jsxs)(n.li,{children:["Azeria Labs. ",(0,s.jsx)(n.a,{href:"https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/",children:'"Heap Exploitation Part 2: Understanding the Glibc Heap Implementation"'}),". Accessed Aug 08, 2021."]}),"\n",(0,s.jsxs)(n.li,{children:["CTF Wiki. ",(0,s.jsx)(n.a,{href:"https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/heap-structure/",children:'"\u5806\u76f8\u5173\u6570\u636e\u7ed3\u6784"'})," (in Chinese). Accessed Aug 10, 2021."]}),"\n",(0,s.jsxs)(n.li,{children:["glibc Contributors. ",(0,s.jsx)(n.a,{href:"https://sourceware.org/git/?p=glibc.git;a=tree;h=6eb9f63e6c9197e967a8cc12a8b235335e5a873d;hb=ae37d06c7d127817ba43850f0f898b793d42aea7",children:"glibc v2.34 source code"}),". Aug 2, 2021. Accessed Aug 8, 2021."]}),"\n",(0,s.jsxs)(n.li,{children:["gcc Contributors. ",(0,s.jsx)(n.a,{href:"https://github.com/gcc-mirror/gcc/tree/releases/gcc-11.2.0",children:"gcc v11.2.0 source code"}),". Jul 28, 2021. Accessed Aug 8, 2021."]}),"\n",(0,s.jsxs)(n.li,{children:["StackOverflow. ",(0,s.jsx)(n.a,{href:"https://stackoverflow.com/questions/197675/how-does-delete-know-the-size-of-the-operand-array",children:'"How does delete[] know the size of the operand array?"'})]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["BTW, while Googling memory leaks, I found a wiki page ",(0,s.jsx)(n.a,{href:"https://wiki.bnl.gov/dayabay/index.php?title=Dealing_With_Memory_Leaks",children:'"Dealing With Memory Leaks"'})," from Daya Bay Reactor Neutrino Experiment project hosted under Brookhaven National Lab's domain. I didn't know that Daya Bay Reactor also hosted a multinational research project \ud83d\ude02."]})]})}function u(e={}){const{wrapper:n}={...(0,o.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},9286:(e,n,t)=>{t.d(n,{Z:()=>h});t(7294);var s=t(512),o=t(6043),r=t(3743),i=t(5999);const a={tocCollapsibleButton:"tocCollapsibleButton_TO0P",tocCollapsibleButtonExpanded:"tocCollapsibleButtonExpanded_MG3E"};var l=t(5893);function c(e){let{collapsed:n,...t}=e;return(0,l.jsx)("button",{type:"button",...t,className:(0,s.Z)("clean-btn",a.tocCollapsibleButton,!n&&a.tocCollapsibleButtonExpanded,t.className),children:(0,l.jsx)(i.Z,{id:"theme.TOCCollapsible.toggleButtonLabel",description:"The label used by the button on the collapsible TOC component",children:"On this page"})})}const d={tocCollapsible:"tocCollapsible_ETCw",tocCollapsibleContent:"tocCollapsibleContent_vkbj",tocCollapsibleExpanded:"tocCollapsibleExpanded_sAul"};function h(e){let{toc:n,className:t,minHeadingLevel:i,maxHeadingLevel:a}=e;const{collapsed:h,toggleCollapsed:u}=(0,o.u)({initialState:!0});return(0,l.jsxs)("div",{className:(0,s.Z)(d.tocCollapsible,!h&&d.tocCollapsibleExpanded,t),children:[(0,l.jsx)(c,{collapsed:h,onClick:u}),(0,l.jsx)(o.z,{lazy:!0,className:d.tocCollapsibleContent,collapsed:h,children:(0,l.jsx)(r.Z,{toc:n,minHeadingLevel:i,maxHeadingLevel:a})})]})}},3743:(e,n,t)=>{t.d(n,{Z:()=>x});var s=t(7294),o=t(6668);function r(e){const n=e.map((e=>({...e,parentIndex:-1,children:[]}))),t=Array(7).fill(-1);n.forEach(((e,n)=>{const s=t.slice(2,e.level);e.parentIndex=Math.max(...s),t[e.level]=n}));const s=[];return n.forEach((e=>{const{parentIndex:t,...o}=e;t>=0?n[t].children.push(o):s.push(o)})),s}function i(e){let{toc:n,minHeadingLevel:t,maxHeadingLevel:s}=e;return n.flatMap((e=>{const n=i({toc:e.children,minHeadingLevel:t,maxHeadingLevel:s});return function(e){return e.level>=t&&e.level<=s}(e)?[{...e,children:n}]:n}))}function a(e){const n=e.getBoundingClientRect();return n.top===n.bottom?a(e.parentNode):n}function l(e,n){let{anchorTopOffset:t}=n;const s=e.find((e=>a(e).top>=t));if(s){return function(e){return e.top>0&&e.bottom<window.innerHeight/2}(a(s))?s:e[e.indexOf(s)-1]??null}return e[e.length-1]??null}function c(){const e=(0,s.useRef)(0),{navbar:{hideOnScroll:n}}=(0,o.L)();return(0,s.useEffect)((()=>{e.current=n?0:document.querySelector(".navbar").clientHeight}),[n]),e}function d(e){const n=(0,s.useRef)(void 0),t=c();(0,s.useEffect)((()=>{if(!e)return()=>{};const{linkClassName:s,linkActiveClassName:o,minHeadingLevel:r,maxHeadingLevel:i}=e;function a(){const e=function(e){return Array.from(document.getElementsByClassName(e))}(s),a=function(e){let{minHeadingLevel:n,maxHeadingLevel:t}=e;const s=[];for(let o=n;o<=t;o+=1)s.push(`h${o}.anchor`);return Array.from(document.querySelectorAll(s.join()))}({minHeadingLevel:r,maxHeadingLevel:i}),c=l(a,{anchorTopOffset:t.current}),d=e.find((e=>c&&c.id===function(e){return decodeURIComponent(e.href.substring(e.href.indexOf("#")+1))}(e)));e.forEach((e=>{!function(e,t){t?(n.current&&n.current!==e&&n.current.classList.remove(o),e.classList.add(o),n.current=e):e.classList.remove(o)}(e,e===d)}))}return document.addEventListener("scroll",a),document.addEventListener("resize",a),a(),()=>{document.removeEventListener("scroll",a),document.removeEventListener("resize",a)}}),[e,t])}var h=t(9960),u=t(5893);function m(e){let{toc:n,className:t,linkClassName:s,isChild:o}=e;return n.length?(0,u.jsx)("ul",{className:o?void 0:t,children:n.map((e=>(0,u.jsxs)("li",{children:[(0,u.jsx)(h.Z,{to:`#${e.id}`,className:s??void 0,dangerouslySetInnerHTML:{__html:e.value}}),(0,u.jsx)(m,{isChild:!0,toc:e.children,className:t,linkClassName:s})]},e.id)))}):null}const p=s.memo(m);function x(e){let{toc:n,className:t="table-of-contents table-of-contents__left-border",linkClassName:a="table-of-contents__link",linkActiveClassName:l,minHeadingLevel:c,maxHeadingLevel:h,...m}=e;const x=(0,o.L)(),f=c??x.tableOfContents.minHeadingLevel,g=h??x.tableOfContents.maxHeadingLevel,b=function(e){let{toc:n,minHeadingLevel:t,maxHeadingLevel:o}=e;return(0,s.useMemo)((()=>i({toc:r(n),minHeadingLevel:t,maxHeadingLevel:o})),[n,t,o])}({toc:n,minHeadingLevel:f,maxHeadingLevel:g});return d((0,s.useMemo)((()=>{if(a&&l)return{linkClassName:a,linkActiveClassName:l,minHeadingLevel:f,maxHeadingLevel:g}}),[a,l,f,g])),(0,u.jsx)(p,{toc:b,className:t,linkClassName:a,...m})}},1151:(e,n,t)=>{t.d(n,{Z:()=>a,a:()=>i});var s=t(7294);const o={},r=s.createContext(o);function i(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);